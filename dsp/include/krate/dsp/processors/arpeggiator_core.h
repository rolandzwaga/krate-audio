// ==============================================================================
// Layer 2: Processor - ArpeggiatorCore (Timing & Event Generation)
// ==============================================================================
// Composes HeldNoteBuffer + NoteSelector (Layer 1) with integer sample-accurate
// timing to produce ArpEvent sequences. Header-only, zero heap allocation in
// all methods.
//
// Constitution Compliance:
// - Principle II: Real-Time Safety (noexcept, zero allocation, no locks, no IO)
// - Principle III: Modern C++ (C++20, enum class, constexpr, std::span)
// - Principle IX: Layer 2 (depends on Layer 0: BlockContext, NoteValue;
//                          Layer 1: HeldNoteBuffer, NoteSelector)
//
// Reference: specs/070-arpeggiator-core/spec.md
// ==============================================================================

#pragma once

#include <krate/dsp/core/block_context.h>
#include <krate/dsp/core/euclidean_pattern.h>
#include <krate/dsp/core/note_value.h>
#include <krate/dsp/core/random.h>
#include <krate/dsp/primitives/arp_lane.h>
#include <krate/dsp/primitives/held_note_buffer.h>

#include <algorithm>
#include <array>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <span>

namespace Krate::DSP {

// =============================================================================
// ArpStepFlags (073-per-step-mods, FR-001)
// =============================================================================

/// @brief Per-step modifier flags stored as bitmask in modifier lane.
/// Multiple flags can be combined on a single step.
/// If kStepActive is not set, the step is a rest (silence).
enum ArpStepFlags : uint8_t {
    kStepActive = 0x01,   ///< Note fires. Off = Rest.
    kStepTie    = 0x02,   ///< Sustain previous note, no retrigger
    kStepSlide  = 0x04,   ///< Legato noteOn, suppress previous noteOff, portamento
    kStepAccent = 0x08,   ///< Velocity boost by accentVelocity_ amount
};

// =============================================================================
// Enumerations (FR-027, FR-028)
// =============================================================================

/// @brief How the arp handles key release.
enum class LatchMode : uint8_t {
    Off = 0,  ///< Stop when all keys released
    Hold,     ///< Continue playing latched pattern; new keys replace
    Add       ///< Accumulate notes into pattern
};

/// @brief When the arp pattern resets.
/// Named ArpRetriggerMode to avoid ODR conflict with RetriggerMode in envelope_utils.h.
enum class ArpRetriggerMode : uint8_t {
    Off = 0,  ///< Never auto-reset
    Note,     ///< Reset on each incoming noteOn
    Beat      ///< Reset at bar boundaries
};

// =============================================================================
// TrigCondition (076-conditional-trigs, FR-001, FR-002)
// =============================================================================

/// @brief Conditional trigger type for per-step condition evaluation.
/// Each arp step has exactly one condition (not a bitmask).
enum class TrigCondition : uint8_t {
    Always = 0,       ///< Step fires unconditionally (default)
    Prob10,           ///< ~10% probability
    Prob25,           ///< ~25% probability
    Prob50,           ///< ~50% probability
    Prob75,           ///< ~75% probability
    Prob90,           ///< ~90% probability
    Ratio_1_2,        ///< Fire on 1st of every 2 loops
    Ratio_2_2,        ///< Fire on 2nd of every 2 loops
    Ratio_1_3,        ///< Fire on 1st of every 3 loops
    Ratio_2_3,        ///< Fire on 2nd of every 3 loops
    Ratio_3_3,        ///< Fire on 3rd of every 3 loops
    Ratio_1_4,        ///< Fire on 1st of every 4 loops
    Ratio_2_4,        ///< Fire on 2nd of every 4 loops
    Ratio_3_4,        ///< Fire on 3rd of every 4 loops
    Ratio_4_4,        ///< Fire on 4th of every 4 loops
    First,            ///< Fire only on first loop (loopCount == 0)
    Fill,             ///< Fire only when fill mode is active
    NotFill,          ///< Fire only when fill mode is NOT active
    kCount            ///< Sentinel (18). Not a valid condition.
};

// =============================================================================
// ArpEvent (FR-001, FR-002)
// =============================================================================

/// @brief A timestamped MIDI event generated by the arpeggiator.
struct ArpEvent {
    enum class Type : uint8_t { NoteOn, NoteOff, kSkip };

    Type type{Type::NoteOn};
    uint8_t note{0};          ///< MIDI note number (0-127), or step index for kSkip
    uint8_t velocity{0};      ///< MIDI velocity (0-127)
    int32_t sampleOffset{0};  ///< Sample position within block [0, blockSize-1]
    bool legato{false};       ///< When true: suppress envelope retrigger, apply portamento
};

// =============================================================================
// ArpeggiatorCore (FR-003 through FR-032)
// =============================================================================

/// @brief Layer 2 DSP processor: arpeggiator timing and event generation.
///
/// Composes HeldNoteBuffer + NoteSelector (Layer 1) with integer timing
/// to produce sample-accurate ArpEvent sequences. Header-only, zero heap
/// allocation in all methods.
///
/// @par Real-Time Safety
/// All methods are noexcept. Zero heap allocation. No locks, exceptions, or I/O.
///
/// @par Usage
/// @code
/// ArpeggiatorCore arp;
/// arp.prepare(44100.0, 512);
/// arp.setEnabled(true);
/// arp.setMode(ArpMode::Up);
/// arp.setNoteValue(NoteValue::Eighth, NoteModifier::None);
/// arp.noteOn(60, 100);
/// arp.noteOn(64, 100);
///
/// std::array<ArpEvent, 128> events;
/// BlockContext ctx;
/// ctx.isPlaying = true;
/// size_t count = arp.processBlock(ctx, events);
/// @endcode
class ArpeggiatorCore {
public:
    // =========================================================================
    // Constants
    // =========================================================================

    static constexpr size_t kMaxEvents = 128;
    static constexpr size_t kMaxPendingNoteOffs = 32;
    static constexpr double kMinSampleRate = 1000.0;
    static constexpr float kMinFreeRate = 0.5f;
    static constexpr float kMaxFreeRate = 50.0f;
    static constexpr float kMinGateLength = 1.0f;
    static constexpr float kMaxGateLength = 200.0f;
    static constexpr float kMinSwing = 0.0f;
    static constexpr float kMaxSwing = 75.0f;

    // =========================================================================
    // Construction (072-independent-lanes: lane defaults for SC-002)
    // =========================================================================

    ArpeggiatorCore() noexcept {
        // Set velocity lane default: length=1, step[0]=1.0f (full passthrough)
        // This ensures SC-002 bit-identical backward compat from first use.
        velocityLane_.setStep(0, 1.0f);
        // Set gate lane default: length=1, step[0]=1.0f (pure global gate)
        gateLane_.setStep(0, 1.0f);
        // Set modifier lane default: length=1, step[0]=kStepActive (0x01)
        // ArpLane<uint8_t> zero-initializes steps to 0x00 = Rest. Without this
        // call, the default modifier lane would silence every arp note.
        modifierLane_.setStep(0, static_cast<uint8_t>(kStepActive));
        // Set ratchet lane default: length=1, step[0]=1 (no ratcheting)
        // ArpLane<uint8_t> zero-initializes steps to 0, which for ratchet
        // would mean count 0 (invalid). Must explicitly set to 1 (FR-003).
        ratchetLane_.setStep(0, static_cast<uint8_t>(1));

        // 075-euclidean-timing: initialize pattern from defaults (FR-001)
        // Without this, euclideanPattern_ would be 0 (the member initializer)
        // instead of the correct E(4,8,0) bitmask.
        regenerateEuclideanPattern();

        // 076-conditional-trigs: initialize condition lane default (FR-005)
        // ArpLane<uint8_t> zero-initializes to 0 = TrigCondition::Always,
        // but explicit set for clarity and consistency.
        conditionLane_.setStep(0, static_cast<uint8_t>(TrigCondition::Always));

        // 077-spice-dice-humanize: initialize overlay arrays to identity (FR-002)
        // velocity = 1.0 (full passthrough), gate = 1.0 (full passthrough),
        // ratchet = 1 (no subdivision), condition = 0 (Always)
        velocityOverlay_.fill(1.0f);
        gateOverlay_.fill(1.0f);
        ratchetOverlay_.fill(1);
        conditionOverlay_.fill(static_cast<uint8_t>(TrigCondition::Always));
    }

    // =========================================================================
    // Lifecycle (FR-003, FR-004)
    // =========================================================================

    /// @brief Initialize for processing.
    /// @param sampleRate Sample rate in Hz (clamped to >= 1000)
    /// @param maxBlockSize Maximum block size (for validation)
    inline void prepare(double sampleRate,
                        [[maybe_unused]] size_t maxBlockSize) noexcept {
        sampleRate_ = (sampleRate >= kMinSampleRate) ? sampleRate : kMinSampleRate;
        reset();
    }

    /// @brief Reset all state to initial values. Configuration preserved.
    inline void reset() noexcept {
        sampleCounter_ = 0;
        currentStepDuration_ = 0;
        swingStepCounter_ = 0;
        wasPlaying_ = false;
        firstStepPending_ = true;
        currentArpNoteCount_ = 0;
        pendingNoteOffCount_ = 0;
        needsDisableNoteOff_ = false;
        physicalKeysHeld_ = 0;
        latchActive_ = false;
        selector_.reset();
        heldNotes_.clear();
        resetLanes();
        regenerateEuclideanPattern();  // 075-euclidean-timing: regenerate from current params (FR-014)
    }

    // =========================================================================
    // MIDI Input (FR-005, FR-006, FR-007)
    // =========================================================================

    /// @brief Handle incoming MIDI note-on.
    /// Applies latch logic (replace vs accumulate) and retrigger logic.
    inline void noteOn(uint8_t note, uint8_t velocity) noexcept {
        ++physicalKeysHeld_;

        // Latch Hold: if currently latched (all keys were released), clear old
        // pattern and start fresh. This replaces the entire latched pattern.
        if (latchMode_ == LatchMode::Hold && latchActive_) {
            heldNotes_.clear();
            latchActive_ = false;
        }
        // Latch Add: always add, never clear (pattern accumulates)
        // Latch Off: standard behavior (just add)

        heldNotes_.noteOn(note, velocity);

        if (retriggerMode_ == ArpRetriggerMode::Note) {
            selector_.reset();
            swingStepCounter_ = 0;
            resetLanes();
        }
    }

    /// @brief Handle incoming MIDI note-off.
    /// Behavior depends on latch mode (remove, ignore, or track).
    inline void noteOff(uint8_t note) noexcept {
        if (physicalKeysHeld_ > 0) {
            --physicalKeysHeld_;
        }

        switch (latchMode_) {
            case LatchMode::Off:
                // Remove from held buffer
                heldNotes_.noteOff(note);
                // If buffer empty, signal that current arp note needs NoteOff
                if (heldNotes_.empty()) {
                    needsDisableNoteOff_ = true;
                }
                break;

            case LatchMode::Hold:
                // Do NOT remove from heldNotes_ -- notes remain for latched pattern.
                // When all physical keys are released, activate latch.
                if (physicalKeysHeld_ == 0) {
                    latchActive_ = true;
                }
                break;

            case LatchMode::Add:
                // Do NOT remove from heldNotes_ -- pattern accumulates indefinitely.
                break;
        }
    }

    // =========================================================================
    // Configuration (FR-008 through FR-018)
    // =========================================================================

    /// @brief Enable or disable the arpeggiator (FR-008, FR-022).
    /// Disable->enable transition resets all lane positions to step 0.
    inline void setEnabled(bool enabled) noexcept {
        if (enabled_ && !enabled) {
            needsDisableNoteOff_ = true;
            ratchetSubStepsRemaining_ = 0;  // 074-ratcheting: clear pending sub-steps (FR-026)
            ratchetSubStepCounter_ = 0;
            ratchetSubStepIndex_ = 0;
        }
        if (!enabled_ && enabled) {
            // FR-022: disable/enable transition resets lanes
            resetLanes();
        }
        enabled_ = enabled;
    }

    /// @brief Set arp mode, delegating to NoteSelector (FR-009).
    /// Also resets swingStepCounter_ to 0 so next step gets even timing.
    inline void setMode(ArpMode mode) noexcept {
        selector_.setMode(mode);  // setMode() calls reset() internally
        swingStepCounter_ = 0;
    }

    /// @brief Set octave range 1-4, delegating to NoteSelector (FR-010).
    inline void setOctaveRange(int octaves) noexcept {
        selector_.setOctaveRange(std::clamp(octaves, 1, 4));
    }

    /// @brief Set octave traversal mode, delegating to NoteSelector (FR-011).
    inline void setOctaveMode(OctaveMode mode) noexcept {
        selector_.setOctaveMode(mode);
    }

    /// @brief Toggle tempo sync vs free rate mode (FR-012).
    inline void setTempoSync(bool sync) noexcept {
        tempoSync_ = sync;
    }

    /// @brief Set tempo-synced step rate (FR-013).
    inline void setNoteValue(NoteValue val, NoteModifier mod) noexcept {
        noteValue_ = val;
        noteModifier_ = mod;
    }

    /// @brief Set free-running rate in Hz, clamped 0.5-50.0 (FR-014).
    inline void setFreeRate(float hz) noexcept {
        freeRateHz_ = std::clamp(hz, kMinFreeRate, kMaxFreeRate);
    }

    /// @brief Set gate length as percentage 1-200% (FR-015).
    inline void setGateLength(float percent) noexcept {
        gateLengthPercent_ = std::clamp(percent, kMinGateLength, kMaxGateLength);
    }

    /// @brief Set swing as percentage 0-75% (FR-016).
    /// Stored internally as 0.0-0.75 (divided by 100).
    inline void setSwing(float percent) noexcept {
        float clamped = std::clamp(percent, kMinSwing, kMaxSwing);
        swing_ = clamped / 100.0f;
    }

    /// @brief Set latch mode (FR-017).
    inline void setLatchMode(LatchMode mode) noexcept {
        latchMode_ = mode;
    }

    /// @brief Set retrigger mode (FR-018).
    inline void setRetrigger(ArpRetriggerMode mode) noexcept {
        retriggerMode_ = mode;
    }

    // =========================================================================
    // Lane Accessors (072-independent-lanes, FR-010 through FR-024)
    // =========================================================================

    /// @brief Access velocity lane for configuration.
    ArpLane<float>& velocityLane() noexcept { return velocityLane_; }

    /// @brief Access velocity lane (const).
    [[nodiscard]] const ArpLane<float>& velocityLane() const noexcept {
        return velocityLane_;
    }

    /// @brief Access gate lane for configuration.
    ArpLane<float>& gateLane() noexcept { return gateLane_; }

    /// @brief Access gate lane (const).
    [[nodiscard]] const ArpLane<float>& gateLane() const noexcept {
        return gateLane_;
    }

    /// @brief Access pitch lane for configuration.
    ArpLane<int8_t>& pitchLane() noexcept { return pitchLane_; }

    /// @brief Access pitch lane (const).
    [[nodiscard]] const ArpLane<int8_t>& pitchLane() const noexcept {
        return pitchLane_;
    }

    // =========================================================================
    // Modifier Lane Accessors (073-per-step-mods, FR-024)
    // =========================================================================

    /// @brief Access the modifier lane for reading/writing step values.
    ArpLane<uint8_t>& modifierLane() noexcept { return modifierLane_; }

    /// @brief Const access to the modifier lane.
    [[nodiscard]] const ArpLane<uint8_t>& modifierLane() const noexcept {
        return modifierLane_;
    }

    // =========================================================================
    // Ratchet Lane Accessors (074-ratcheting, FR-006)
    // =========================================================================

    /// @brief Access the ratchet lane for reading/writing step values.
    ArpLane<uint8_t>& ratchetLane() noexcept { return ratchetLane_; }

    /// @brief Const access to the ratchet lane.
    [[nodiscard]] const ArpLane<uint8_t>& ratchetLane() const noexcept {
        return ratchetLane_;
    }

    // =========================================================================
    // Euclidean Timing Setters (075-euclidean-timing, FR-009, FR-010)
    // =========================================================================

    /// @brief Set the number of steps in the Euclidean pattern.
    /// Clamps to [kMinSteps (2), kMaxSteps (32)].
    /// Also re-clamps euclideanHits_ to [0, new step count].
    /// Regenerates the pattern bitmask.
    inline void setEuclideanSteps(int steps) noexcept {
        euclideanSteps_ = std::clamp(steps,
            EuclideanPattern::kMinSteps, EuclideanPattern::kMaxSteps);
        // Re-clamp hits against new step count
        euclideanHits_ = std::clamp(euclideanHits_, 0, euclideanSteps_);
        regenerateEuclideanPattern();
    }

    /// @brief Set the number of hit pulses in the Euclidean pattern.
    /// Clamps to [0, euclideanSteps_].
    /// Regenerates the pattern bitmask.
    inline void setEuclideanHits(int hits) noexcept {
        euclideanHits_ = std::clamp(hits, 0, euclideanSteps_);
        regenerateEuclideanPattern();
    }

    /// @brief Set the rotation offset for the Euclidean pattern.
    /// Clamps to [0, kMaxSteps - 1 (31)].
    /// Regenerates the pattern bitmask.
    inline void setEuclideanRotation(int rotation) noexcept {
        euclideanRotation_ = std::clamp(rotation, 0,
            EuclideanPattern::kMaxSteps - 1);
        regenerateEuclideanPattern();
    }

    /// @brief Enable or disable Euclidean timing mode.
    /// When transitioning from disabled to enabled, resets euclideanPosition_ to 0.
    /// Does NOT clear ratchet sub-step state (in-flight sub-steps complete normally).
    inline void setEuclideanEnabled(bool enabled) noexcept {
        if (!euclideanEnabled_ && enabled) {
            // Transitioning from disabled to enabled: reset position (FR-010)
            euclideanPosition_ = 0;
            // Do NOT clear ratchet sub-step state -- in-flight sub-steps complete
        }
        euclideanEnabled_ = enabled;
    }

    // =========================================================================
    // Euclidean Timing Getters (075-euclidean-timing, FR-015)
    // =========================================================================

    /// @brief Check if Euclidean timing mode is enabled.
    [[nodiscard]] inline bool euclideanEnabled() const noexcept {
        return euclideanEnabled_;
    }

    /// @brief Get the number of hit pulses in the Euclidean pattern.
    [[nodiscard]] inline int euclideanHits() const noexcept {
        return euclideanHits_;
    }

    /// @brief Get the number of steps in the Euclidean pattern.
    [[nodiscard]] inline int euclideanSteps() const noexcept {
        return euclideanSteps_;
    }

    /// @brief Get the rotation offset for the Euclidean pattern.
    [[nodiscard]] inline int euclideanRotation() const noexcept {
        return euclideanRotation_;
    }

    // =========================================================================
    // Condition Lane Accessors (076-conditional-trigs, FR-007)
    // =========================================================================

    /// @brief Access the condition lane for reading/writing step values.
    ArpLane<uint8_t>& conditionLane() noexcept { return conditionLane_; }

    /// @brief Const access to the condition lane.
    [[nodiscard]] const ArpLane<uint8_t>& conditionLane() const noexcept {
        return conditionLane_;
    }

    // =========================================================================
    // Fill Mode (076-conditional-trigs, FR-020, FR-021)
    // =========================================================================

    /// @brief Set fill mode active state. Real-time safe, no side effects.
    void setFillActive(bool active) noexcept { fillActive_ = active; }

    /// @brief Get current fill mode state.
    [[nodiscard]] bool fillActive() const noexcept { return fillActive_; }

    /// @brief Set the accent velocity boost amount.
    /// @param amount Additive velocity boost for accented steps (0-127).
    void setAccentVelocity(int amount) noexcept {
        accentVelocity_ = std::clamp(amount, 0, 127);
    }

    /// @brief Set the slide portamento time.
    /// @param ms Portamento duration in milliseconds (0-500).
    void setSlideTime(float ms) noexcept {
        slideTimeMs_ = std::clamp(ms, 0.0f, 500.0f);
    }

    /// @brief Get the current accent velocity boost amount.
    /// @return Clamped accent velocity value in [0, 127].
    [[nodiscard]] int accentVelocity() const noexcept {
        return accentVelocity_;
    }

    /// @brief Get the current slide portamento time.
    /// @return Clamped slide time in milliseconds in [0, 500].
    [[nodiscard]] float slideTimeMs() const noexcept {
        return slideTimeMs_;
    }

    /// @brief Set ratchet swing as percentage 50-75%.
    /// Controls the long-short ratio within ratcheted sub-step pairs.
    /// 50% = equal spacing (default), 67% = triplet feel, 75% = dotted feel.
    /// Stored internally as 0.50-0.75 (divided by 100).
    void setRatchetSwing(float percent) noexcept {
        ratchetSwing_ = std::clamp(percent, 50.0f, 75.0f) / 100.0f;
    }

    // =========================================================================
    // Spice/Dice & Humanize (077-spice-dice-humanize)
    // =========================================================================

    /// Set Spice blend amount (0.0 = original, 1.0 = full overlay).
    void setSpice(float value) noexcept {
        spice_ = std::clamp(value, 0.0f, 1.0f);
    }

    /// Get current Spice blend amount.
    [[nodiscard]] float spice() const noexcept { return spice_; }

    /// Set Humanize amount (0.0 = quantized, 1.0 = max variation).
    void setHumanize(float value) noexcept {
        humanize_ = std::clamp(value, 0.0f, 1.0f);
    }

    /// Get current Humanize amount.
    [[nodiscard]] float humanize() const noexcept { return humanize_; }

    /// Generate new random overlay values for all four lanes (FR-005).
    /// Real-time safe: no allocation, no exceptions, no I/O.
    void triggerDice() noexcept {
        // Velocity: 32 unipolar floats in [0.0, 1.0]
        for (auto& v : velocityOverlay_) {
            v = spiceDiceRng_.nextUnipolar();
        }
        // Gate: 32 unipolar floats in [0.0, 1.0]
        for (auto& g : gateOverlay_) {
            g = spiceDiceRng_.nextUnipolar();
        }
        // Ratchet: 32 values in [1, 4]
        for (auto& r : ratchetOverlay_) {
            r = static_cast<uint8_t>(spiceDiceRng_.next() % 4 + 1);
        }
        // Condition: 32 values in [0, 17]
        for (auto& c : conditionOverlay_) {
            c = static_cast<uint8_t>(
                spiceDiceRng_.next() % static_cast<uint32_t>(TrigCondition::kCount));
        }
    }

    // =========================================================================
    // Processing (FR-019 through FR-024)
    // =========================================================================

    /// @brief Process one audio block, generating arp events.
    /// @param ctx Block context (tempo, sample rate, transport state)
    /// @param outputEvents Caller-owned span to receive events (capacity >= 64)
    /// @return Number of events written to outputEvents
    ///
    /// @pre outputEvents.size() >= kMaxEvents
    /// @post All events have sampleOffset in [0, ctx.blockSize-1]
    inline size_t processBlock(const BlockContext& ctx,
                               std::span<ArpEvent> outputEvents) noexcept {
        // (a) Zero blockSize guard (FR-032) -- no state change
        if (ctx.blockSize == 0) {
            return 0;
        }

        // Cap event emission to output span size
        const size_t maxEvents = (outputEvents.size() < kMaxEvents)
                                     ? outputEvents.size()
                                     : kMaxEvents;

        size_t eventCount = 0;

        // (c) Disabled check (FR-008)
        if (!enabled_) {
            if (needsDisableNoteOff_) {
                // Emit NoteOff for all currently sounding arp notes
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, 0};
                }
                // Emit pending NoteOffs, skipping duplicates already emitted
                // from currentArpNotes_ (FR-027, 082-presets-polish)
                for (size_t i = 0; i < pendingNoteOffCount_ && eventCount < maxEvents; ++i) {
                    bool alreadyEmitted = false;
                    for (size_t j = 0; j < currentArpNoteCount_; ++j) {
                        if (pendingNoteOffs_[i].note == currentArpNotes_[j]) {
                            alreadyEmitted = true;
                            break;
                        }
                    }
                    if (!alreadyEmitted) {
                        outputEvents[eventCount++] = ArpEvent{
                            ArpEvent::Type::NoteOff, pendingNoteOffs_[i].note, 0, 0};
                    }
                }
                currentArpNoteCount_ = 0;
                pendingNoteOffCount_ = 0;
                needsDisableNoteOff_ = false;
            }
            return eventCount;
        }

        // (d) Transport not playing check (FR-031)
        if (!ctx.isPlaying) {
            if (wasPlaying_) {
                // Transport just stopped -- emit NoteOffs for all currently
                // sounding arp notes at sampleOffset 0.
                // currentArpNotes_ tracks all notes with active gate;
                // pendingNoteOffs_ tracks the same notes' scheduled NoteOffs.
                // We emit from currentArpNotes_ only to avoid duplicates.
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, 0};
                }
                currentArpNoteCount_ = 0;
                pendingNoteOffCount_ = 0;
                ratchetSubStepsRemaining_ = 0;  // 074-ratcheting (FR-027)
                ratchetSubStepCounter_ = 0;
                ratchetSubStepIndex_ = 0;
            }
            wasPlaying_ = false;
            return eventCount;
        }

        // Handle transport restart (FR-023, FR-025): reset step counters
        // and lane positions so the arp restarts cleanly from step 1.
        if (!wasPlaying_) {
            wasPlaying_ = true;
            firstStepPending_ = true;
            sampleCounter_ = 0;
            selector_.reset();
            swingStepCounter_ = 0;
            resetLanes();
        }

        // (g) firstStepPending_: compute initial step duration before loop
        if (firstStepPending_) {
            currentStepDuration_ = calculateStepDuration(ctx);
            firstStepPending_ = false;
        }

        // Empty buffer with latch Off: emit NoteOff for current arp notes,
        // flush all pending NoteOffs, then return (FR-007, FR-024)
        if (heldNotes_.empty()) {
            // If buffer just became empty (latch Off, all keys released),
            // emit NoteOff for currently sounding arp note(s) and flush
            // ALL pending NoteOffs at sampleOffset 0 to prevent stuck notes.
            if (needsDisableNoteOff_) {
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, 0};
                }
                // Flush all pending NoteOffs immediately at sampleOffset 0
                for (size_t i = 0; i < pendingNoteOffCount_ && eventCount < maxEvents; ++i) {
                    // Avoid duplicate: only emit if not already in currentArpNotes_
                    // (which we just emitted above). Since pending NoteOffs track
                    // notes that ARE in currentArpNotes_, skip duplicates.
                    bool alreadyEmitted = false;
                    for (size_t j = 0; j < currentArpNoteCount_; ++j) {
                        if (pendingNoteOffs_[i].note == currentArpNotes_[j]) {
                            alreadyEmitted = true;
                            break;
                        }
                    }
                    if (!alreadyEmitted) {
                        outputEvents[eventCount++] = ArpEvent{
                            ArpEvent::Type::NoteOff, pendingNoteOffs_[i].note, 0, 0};
                    }
                }
                currentArpNoteCount_ = 0;
                pendingNoteOffCount_ = 0;
                needsDisableNoteOff_ = false;
            }
            return eventCount;
        }

        // Retrigger Beat: detect bar boundary within this block (FR-023)
        // Compute once before the loop; store as samples-from-block-start.
        size_t barBoundaryOffset = SIZE_MAX;  // SIZE_MAX = no boundary
        if (retriggerMode_ == ArpRetriggerMode::Beat) {
            barBoundaryOffset = detectBarBoundary(ctx);
        }

        // Jump-ahead main loop
        size_t samplesProcessed = 0;
        const size_t blockSize = ctx.blockSize;

        while (samplesProcessed < blockSize && eventCount < maxEvents) {
            // How many samples until next step boundary?
            size_t samplesUntilStep = currentStepDuration_ - sampleCounter_;

            // Find minimum pending NoteOff samplesRemaining (relative to
            // samplesProcessed position)
            size_t samplesUntilNoteOff = SIZE_MAX;
            for (size_t i = 0; i < pendingNoteOffCount_; ++i) {
                if (pendingNoteOffs_[i].samplesRemaining < samplesUntilNoteOff) {
                    samplesUntilNoteOff = pendingNoteOffs_[i].samplesRemaining;
                }
            }

            // Retrigger Beat: how many samples until bar boundary?
            size_t samplesUntilBar = SIZE_MAX;
            if (barBoundaryOffset != SIZE_MAX &&
                barBoundaryOffset >= samplesProcessed) {
                samplesUntilBar = barBoundaryOffset - samplesProcessed;
            }

            // Jump to the minimum of (step boundary, pending NoteOff,
            // bar boundary, block end)
            size_t samplesUntilBlockEnd = blockSize - samplesProcessed;
            size_t jump = samplesUntilBlockEnd;  // default: consume to block end

            // 074-ratcheting: sub-step boundary timing (FR-014)
            // 078-ratchet-swing: use per-sub-step duration from array
            size_t samplesUntilSubStep = SIZE_MAX;
            if (ratchetSubStepsRemaining_ > 0) {
                samplesUntilSubStep = ratchetSubStepDurations_[ratchetSubStepIndex_] - ratchetSubStepCounter_;
            }

            // Determine which event fires first
            // Priority: BarBoundary > NoteOff > Step > SubStep (FR-014)
            enum class NextEvent { BlockEnd, NoteOff, Step, SubStep, BarBoundary };
            NextEvent next = NextEvent::BlockEnd;

            if (samplesUntilStep <= jump) {
                jump = samplesUntilStep;
                next = NextEvent::Step;
            }
            // SubStep: lower priority than Step (FR-014)
            if (samplesUntilSubStep < jump) {
                jump = samplesUntilSubStep;
                next = NextEvent::SubStep;
            } else if (samplesUntilSubStep == jump && next == NextEvent::BlockEnd) {
                // SubStep fires at block end boundary -- process SubStep
                jump = samplesUntilSubStep;
                next = NextEvent::SubStep;
            }
            if (samplesUntilNoteOff < jump ||
                (samplesUntilNoteOff == jump && next != NextEvent::Step)) {
                // NoteOff fires before or at same time as step (NoteOff before
                // NoteOn at same offset per FR-021)
                jump = samplesUntilNoteOff;
                next = NextEvent::NoteOff;
            }
            // If NoteOff and Step fire at the same sample, process NoteOff first
            // (FR-021 event ordering)
            if (samplesUntilNoteOff == samplesUntilStep &&
                samplesUntilStep <= samplesUntilBlockEnd) {
                next = NextEvent::NoteOff;
            }
            // If NoteOff and SubStep fire at the same sample, process NoteOff first
            if (samplesUntilNoteOff == samplesUntilSubStep &&
                samplesUntilSubStep <= samplesUntilBlockEnd) {
                next = NextEvent::NoteOff;
            }
            // Bar boundary: must fire before or at same time as step
            if (samplesUntilBar < jump) {
                jump = samplesUntilBar;
                next = NextEvent::BarBoundary;
            } else if (samplesUntilBar == jump &&
                       (next == NextEvent::Step || next == NextEvent::SubStep)) {
                // Bar boundary and step/substep at same sample: bar reset first
                next = NextEvent::BarBoundary;
            }

            // Advance time by jump amount
            sampleCounter_ += jump;
            samplesProcessed += jump;
            decrementPendingNoteOffs(jump);
            // 074-ratcheting: advance sub-step counter (FR-016)
            if (ratchetSubStepsRemaining_ > 0) {
                ratchetSubStepCounter_ += jump;
            }

            if (next == NextEvent::BlockEnd) {
                // No events fire -- we consumed the rest of the block
                break;
            }

            int32_t sampleOffset = static_cast<int32_t>(samplesProcessed);

            // Guard: if event fires exactly at blockSize, defer to next block
            if (samplesProcessed >= blockSize) {
                break;
            }

            if (next == NextEvent::BarBoundary) {
                // Bar boundary: reset selector and swing counter (FR-023)
                selector_.reset();
                swingStepCounter_ = 0;
                resetLanes();
                // Invalidate bar boundary so it doesn't fire again this block
                barBoundaryOffset = SIZE_MAX;

                // Emit any pending NoteOffs that are due at this sample
                emitDuePendingNoteOffs(sampleOffset, outputEvents, eventCount,
                                       maxEvents);

                // If step boundary also fires at this exact sample, process it
                if (sampleCounter_ >= currentStepDuration_) {
                    sampleCounter_ = 0;
                    // Recalculate step duration after swing reset
                    currentStepDuration_ = calculateStepDuration(ctx);
                    fireStep(ctx, sampleOffset, outputEvents, eventCount,
                             maxEvents, samplesProcessed, blockSize);
                } else {
                    // Recalculate current step duration with reset swing counter
                    currentStepDuration_ = calculateStepDuration(ctx);
                    // Adjust sampleCounter_ to reflect position within new step
                    // (the counter has been counting into the old step duration;
                    // keep the same elapsed count but against the new duration)
                }
            } else if (next == NextEvent::NoteOff) {
                // Emit all pending NoteOffs that are due at this sample
                emitDuePendingNoteOffs(sampleOffset, outputEvents, eventCount, maxEvents);

                // After emitting NoteOffs, check if step boundary also fires
                // at this exact sample
                if (sampleCounter_ >= currentStepDuration_) {
                    // Step fires at same offset -- process it
                    sampleCounter_ = 0;
                    // 074-ratcheting: recalculate before fireStep (FR-025)
                    currentStepDuration_ = calculateStepDuration(ctx);
                    fireStep(ctx, sampleOffset, outputEvents, eventCount, maxEvents,
                             samplesProcessed, blockSize);
                }
                // 074-ratcheting: NoteOff-coincident SubStep check (FR-015)
                // 078-ratchet-swing: use per-sub-step duration from array
                else if (ratchetSubStepsRemaining_ > 0 &&
                         ratchetSubStepCounter_ >= ratchetSubStepDurations_[ratchetSubStepIndex_]) {
                    fireSubStep(ctx, sampleOffset, outputEvents, eventCount, maxEvents);
                }
            } else if (next == NextEvent::Step) {
                // Step boundary reached
                sampleCounter_ = 0;
                // 074-ratcheting: Recalculate step duration before fireStep.
                // The previous step's fireStep() already incremented swingStepCounter_
                // but may have deferred the recalculation (when ratchetCount > 1).
                // This ensures fireStep() sees the correct base duration for
                // sub-step calculations. (FR-025)
                currentStepDuration_ = calculateStepDuration(ctx);

                // First emit any pending NoteOffs that are also due at this sample
                emitDuePendingNoteOffs(sampleOffset, outputEvents, eventCount, maxEvents);

                fireStep(ctx, sampleOffset, outputEvents, eventCount, maxEvents,
                         samplesProcessed, blockSize);
            } else if (next == NextEvent::SubStep) {
                // 074-ratcheting: Sub-step boundary reached (FR-015)
                fireSubStep(ctx, sampleOffset, outputEvents, eventCount, maxEvents);
            }
        }

        // Decrement remaining pending NoteOffs by the unused portion of the block
        // (already handled by the jump-ahead loop consuming all samples)
        return eventCount;
    }

private:
    // =========================================================================
    // Internal Types
    // =========================================================================

    /// @brief Tracks a pending NoteOff that spans across block boundaries.
    struct PendingNoteOff {
        uint8_t note{0};
        size_t samplesRemaining{0};
    };

    // =========================================================================
    // Internal Methods
    // =========================================================================

    /// @brief Calculate step duration in samples from current settings.
    /// Uses double precision to avoid float * double precision loss.
    /// Returns at minimum 1 sample.
    inline size_t calculateStepDuration(const BlockContext& ctx) const noexcept {
        size_t baseDuration = 0;
        if (tempoSync_) {
            // (f) Double-precision: cast getBeatsForNote() to double before multiply
            double beatsPerStep = static_cast<double>(
                getBeatsForNote(noteValue_, noteModifier_));
            double secondsPerBeat = 60.0 / ctx.tempoBPM;
            baseDuration = static_cast<size_t>(
                secondsPerBeat * beatsPerStep * ctx.sampleRate);
        } else {
            baseDuration = static_cast<size_t>(sampleRate_ / static_cast<double>(freeRateHz_));
        }

        // Apply swing
        size_t swungDuration = baseDuration;
        if (swing_ > 0.0f) {
            double swingVal = static_cast<double>(swing_);
            if (swingStepCounter_ % 2 == 0) {
                // Even step: lengthen
                swungDuration = static_cast<size_t>(
                    static_cast<double>(baseDuration) * (1.0 + swingVal));
            } else {
                // Odd step: shorten
                swungDuration = static_cast<size_t>(
                    static_cast<double>(baseDuration) * (1.0 - swingVal));
            }
        }

        // Clamp to minimum 1 sample
        return (swungDuration > 0) ? swungDuration : 1;
    }

    /// @brief Detect if a bar boundary falls within the current block.
    /// @return Offset within block (0 to blockSize-1) of the bar boundary,
    ///         or SIZE_MAX if no bar boundary falls within this block.
    /// Uses ctx.transportPositionSamples and ctx.samplesPerBar() (FR-023).
    inline size_t detectBarBoundary(const BlockContext& ctx) const noexcept {
        const size_t barSamples = ctx.samplesPerBar();
        if (barSamples == 0) {
            return SIZE_MAX;  // Prevent division by zero
        }

        const int64_t blockStart = ctx.transportPositionSamples;
        if (blockStart < 0) {
            return SIZE_MAX;  // Invalid transport position
        }

        const int64_t barSamplesI64 = static_cast<int64_t>(barSamples);
        const int64_t remainder = blockStart % barSamplesI64;

        int64_t barBoundarySample = 0;
        if (remainder == 0) {
            // Block starts exactly at a bar boundary
            barBoundarySample = 0;
        } else {
            // Next bar boundary is barSamples - remainder into the block
            barBoundarySample = barSamplesI64 - remainder;
        }

        // Check if bar boundary falls within [0, blockSize)
        if (barBoundarySample >= 0 &&
            barBoundarySample < static_cast<int64_t>(ctx.blockSize)) {
            return static_cast<size_t>(barBoundarySample);
        }

        return SIZE_MAX;  // No bar boundary in this block
    }

    /// @brief Calculate gate duration in samples from current step duration.
    /// Gate duration = stepDuration * gateLengthPercent / 100 * gateLaneValue,
    /// clamped to minimum 1 sample (FR-014: ensures NoteOff always fires).
    /// @param gateLaneValue Gate lane multiplier (default 1.0f for backward compat)
    inline size_t calculateGateDuration(float gateLaneValue = 1.0f) const noexcept {
        return std::max(size_t{1}, static_cast<size_t>(
            static_cast<double>(currentStepDuration_) *
            static_cast<double>(gateLengthPercent_) / 100.0 *
            static_cast<double>(gateLaneValue)));
    }

    /// @brief Compute per-sub-step durations and gate durations with ratchet swing.
    /// Groups sub-steps into consecutive pairs and applies swingRatio to each pair.
    /// Odd remainder (count 3) keeps baseDuration for the last sub-step.
    inline void computeSwungSubStepDurations(
        size_t stepDuration, uint8_t ratchetCount,
        float gateScale, float gateOffsetRatio) noexcept
    {
        const size_t baseDuration = stepDuration / static_cast<size_t>(ratchetCount);
        const size_t numPairs = static_cast<size_t>(ratchetCount) / 2;
        const bool hasRemainder = (ratchetCount % 2) != 0;

        for (size_t pair = 0; pair < numPairs; ++pair) {
            const size_t pairDuration = 2 * baseDuration;
            const size_t longDur = static_cast<size_t>(
                std::round(static_cast<double>(pairDuration) *
                           static_cast<double>(ratchetSwing_)));
            const size_t shortDur = pairDuration - longDur;

            const size_t evenIdx = pair * 2;
            const size_t oddIdx = evenIdx + 1;

            ratchetSubStepDurations_[evenIdx] = (longDur > 0) ? longDur : 1;
            ratchetSubStepDurations_[oddIdx] = (shortDur > 0) ? shortDur : 1;

            // Gate for each sub-step: subStepDuration * gate% / 100 * gateScale
            auto computeGate = [&](size_t dur) -> size_t {
                size_t gate = std::max(size_t{1}, static_cast<size_t>(
                    static_cast<double>(dur) *
                    static_cast<double>(gateLengthPercent_) / 100.0 *
                    static_cast<double>(gateScale)));
                // Apply humanize gate offset
                int32_t humanizedGate = static_cast<int32_t>(gate)
                    + static_cast<int32_t>(static_cast<float>(gate) * gateOffsetRatio);
                return static_cast<size_t>(std::max(int32_t{1}, humanizedGate));
            };
            ratchetGateDurations_[evenIdx] = computeGate(longDur > 0 ? longDur : 1);
            ratchetGateDurations_[oddIdx] = computeGate(shortDur > 0 ? shortDur : 1);
        }

        if (hasRemainder) {
            const size_t lastIdx = static_cast<size_t>(ratchetCount) - 1;
            ratchetSubStepDurations_[lastIdx] = (baseDuration > 0) ? baseDuration : 1;
            size_t gate = std::max(size_t{1}, static_cast<size_t>(
                static_cast<double>(baseDuration) *
                static_cast<double>(gateLengthPercent_) / 100.0 *
                static_cast<double>(gateScale)));
            int32_t humanizedGate = static_cast<int32_t>(gate)
                + static_cast<int32_t>(static_cast<float>(gate) * gateOffsetRatio);
            ratchetGateDurations_[lastIdx] = static_cast<size_t>(
                std::max(int32_t{1}, humanizedGate));
        }
    }

    /// @brief Decrement all pending NoteOff samplesRemaining by given amount.
    inline void decrementPendingNoteOffs(size_t samples) noexcept {
        for (size_t i = 0; i < pendingNoteOffCount_; ++i) {
            if (pendingNoteOffs_[i].samplesRemaining >= samples) {
                pendingNoteOffs_[i].samplesRemaining -= samples;
            } else {
                pendingNoteOffs_[i].samplesRemaining = 0;
            }
        }
    }

    /// @brief Emit all pending NoteOffs whose samplesRemaining == 0.
    /// Removes them from the array by compacting.
    inline void emitDuePendingNoteOffs(int32_t sampleOffset,
                                        std::span<ArpEvent> outputEvents,
                                        size_t& eventCount,
                                        size_t maxEvents) noexcept {
        size_t i = 0;
        while (i < pendingNoteOffCount_ && eventCount < maxEvents) {
            if (pendingNoteOffs_[i].samplesRemaining == 0) {
                // Emit NoteOff event
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOff,
                    pendingNoteOffs_[i].note,
                    0,
                    sampleOffset};

                // Remove from currentArpNotes_ tracking
                removeFromCurrentArpNotes(pendingNoteOffs_[i].note);

                // Compact: move last element to this slot
                pendingNoteOffs_[i] = pendingNoteOffs_[pendingNoteOffCount_ - 1];
                --pendingNoteOffCount_;
                // Don't increment i -- re-check the swapped element
            } else {
                ++i;
            }
        }
    }

    /// @brief Add a pending NoteOff to the array.
    /// If at capacity, emit the oldest one at sampleOffset 0 (overflow handling).
    inline void addPendingNoteOff(uint8_t note, size_t samplesRemaining,
                                   std::span<ArpEvent> outputEvents,
                                   size_t& eventCount,
                                   size_t maxEvents) noexcept {
        if (pendingNoteOffCount_ >= kMaxPendingNoteOffs) {
            // Overflow: emit oldest (first entry) at sampleOffset 0
            if (eventCount < maxEvents) {
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOff,
                    pendingNoteOffs_[0].note,
                    0,
                    0};
                removeFromCurrentArpNotes(pendingNoteOffs_[0].note);
            }
            // Compact: shift everything down
            for (size_t i = 1; i < pendingNoteOffCount_; ++i) {
                pendingNoteOffs_[i - 1] = pendingNoteOffs_[i];
            }
            --pendingNoteOffCount_;
        }

        pendingNoteOffs_[pendingNoteOffCount_] = PendingNoteOff{note, samplesRemaining};
        ++pendingNoteOffCount_;
    }

    /// @brief Fire a ratchet sub-step: emit noteOn(s), schedule noteOff, advance state.
    /// Called from processBlock() when NextEvent::SubStep fires or when a NoteOff
    /// coincides with a sub-step boundary. (074-ratcheting, FR-015)
    inline void fireSubStep([[maybe_unused]] const BlockContext& ctx,
                             int32_t sampleOffset,
                             std::span<ArpEvent> outputEvents,
                             size_t& eventCount,
                             size_t maxEvents) noexcept {
        // (1) Emit pending NoteOffs due at this sample offset FIRST (FR-021 ordering)
        emitDuePendingNoteOffs(sampleOffset, outputEvents, eventCount, maxEvents);

        // 078-ratchet-swing: advance sub-step index to the sub-step being fired
        ++ratchetSubStepIndex_;

        // (2) Emit noteOn for ratcheted note(s)
        if (ratchetNoteCount_ > 1) {
            // Chord mode: emit noteOn for all chord notes
            for (size_t i = 0; i < ratchetNoteCount_ && eventCount < maxEvents; ++i) {
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOn,
                    ratchetNotes_[i],
                    ratchetVelocities_[i],
                    sampleOffset,
                    false};  // Sub-steps after first are never legato
            }
            // Update currentArpNotes_ tracking
            for (size_t i = 0; i < ratchetNoteCount_ && i < 32; ++i) {
                currentArpNotes_[i] = ratchetNotes_[i];
            }
            currentArpNoteCount_ = ratchetNoteCount_ < 32 ? ratchetNoteCount_ : 32;
        } else {
            // Single note mode
            if (eventCount < maxEvents) {
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOn,
                    ratchetNote_,
                    ratchetVelocity_,
                    sampleOffset,
                    false};  // Sub-steps after first are never legato
            }
            currentArpNotes_[0] = ratchetNote_;
            currentArpNoteCount_ = 1;
        }

        // (3) Schedule pending noteOff using per-sub-step gate duration
        // 078-ratchet-swing: use ratchetGateDurations_[ratchetSubStepIndex_]
        // For the last sub-step, check look-ahead: if next step is Tie/Slide,
        // suppress the gate noteOff so the note sustains into the next step (FR-022).
        // Sub-steps 0 through N-2 always schedule their noteOffs normally.
        bool suppressGateNoteOff = false;
        if (ratchetIsLastSubStep_) {
            uint8_t nextModFlags = modifierLane_.getStep(
                static_cast<size_t>(modifierLane_.currentStep()));
            bool nextStepIsTie = (nextModFlags & kStepActive) != 0 &&
                                 (nextModFlags & kStepTie) != 0;
            bool nextStepIsSlide = (nextModFlags & kStepActive) != 0 &&
                                   (nextModFlags & kStepSlide) != 0;
            suppressGateNoteOff = nextStepIsTie || nextStepIsSlide;
        }

        const size_t subGate = ratchetGateDurations_[ratchetSubStepIndex_];
        if (!suppressGateNoteOff) {
            if (ratchetNoteCount_ > 1) {
                for (size_t i = 0; i < ratchetNoteCount_; ++i) {
                    addPendingNoteOff(ratchetNotes_[i], subGate,
                                       outputEvents, eventCount, maxEvents);
                }
            } else {
                addPendingNoteOff(ratchetNote_, subGate,
                                   outputEvents, eventCount, maxEvents);
            }
        }

        // (4) Decrement remaining count and reset counter
        --ratchetSubStepsRemaining_;
        ratchetSubStepCounter_ = 0;

        // Update last-sub-step flag for next sub-step
        ratchetIsLastSubStep_ = (ratchetSubStepsRemaining_ == 1);
    }

    // =========================================================================
    // Condition Evaluation (076-conditional-trigs, FR-013)
    // =========================================================================

    /// @brief Evaluate a TrigCondition for the current step.
    /// @param condition The condition to evaluate (TrigCondition enum as uint8_t)
    /// @return true if the step should fire, false if it should be treated as rest
    /// Consumes conditionRng_ only for probability conditions (Prob10-Prob90).
    /// Uses loopCount_ for A:B ratio and First conditions.
    /// Uses fillActive_ for Fill/NotFill conditions.
    /// Values >= kCount are treated as Always (defensive fallback).
    inline bool evaluateCondition(uint8_t condition) noexcept {
        const auto cond = static_cast<TrigCondition>(condition);
        switch (cond) {
            case TrigCondition::Always:
                return true;
            case TrigCondition::Prob10:
                return conditionRng_.nextUnipolar() < 0.10f;
            case TrigCondition::Prob25:
                return conditionRng_.nextUnipolar() < 0.25f;
            case TrigCondition::Prob50:
                return conditionRng_.nextUnipolar() < 0.50f;
            case TrigCondition::Prob75:
                return conditionRng_.nextUnipolar() < 0.75f;
            case TrigCondition::Prob90:
                return conditionRng_.nextUnipolar() < 0.90f;
            case TrigCondition::Ratio_1_2:
                return loopCount_ % 2 == 0;
            case TrigCondition::Ratio_2_2:
                return loopCount_ % 2 == 1;
            case TrigCondition::Ratio_1_3:
                return loopCount_ % 3 == 0;
            case TrigCondition::Ratio_2_3:
                return loopCount_ % 3 == 1;
            case TrigCondition::Ratio_3_3:
                return loopCount_ % 3 == 2;
            case TrigCondition::Ratio_1_4:
                return loopCount_ % 4 == 0;
            case TrigCondition::Ratio_2_4:
                return loopCount_ % 4 == 1;
            case TrigCondition::Ratio_3_4:
                return loopCount_ % 4 == 2;
            case TrigCondition::Ratio_4_4:
                return loopCount_ % 4 == 3;
            case TrigCondition::First:
                return loopCount_ == 0;
            case TrigCondition::Fill:
                return fillActive_;
            case TrigCondition::NotFill:
                return !fillActive_;
            default:
                return true;  // Out-of-range: treat as Always (defensive)
        }
    }

    /// @brief Fire a step: advance NoteSelector, emit NoteOn, schedule NoteOff.
    inline void fireStep(const BlockContext& ctx,
                          int32_t sampleOffset,
                          std::span<ArpEvent> outputEvents,
                          size_t& eventCount,
                          size_t maxEvents,
                          [[maybe_unused]] size_t samplesProcessed,
                          [[maybe_unused]] size_t blockSize) noexcept {
        // Advance NoteSelector to get next note(s)
        ArpNoteResult result = selector_.advance(heldNotes_);

        if (result.count > 0) {
            // 077-spice-dice-humanize: capture overlay indices BEFORE lane advances (FR-010)
            const size_t velStep = velocityLane_.currentStep();
            const size_t gateStep = gateLane_.currentStep();
            const size_t ratchetStep = ratchetLane_.currentStep();
            const size_t condStep = conditionLane_.currentStep();

            // Advance all lanes (once per step, regardless of chord size)
            float velScale = velocityLane_.advance();
            float gateScale = gateLane_.advance();
            int8_t pitchOffset = pitchLane_.advance();
            uint8_t modifierFlags = modifierLane_.advance();
            uint8_t ratchetCount = std::max(uint8_t{1}, ratchetLane_.advance());  // 074-ratcheting (FR-004)
            uint8_t condValue = conditionLane_.advance();  // 076-conditional-trigs (FR-006)

            // 077-spice-dice-humanize: apply Spice blend (FR-008, FR-009)
            if (spice_ > 0.0f) {
                // Velocity: linear interpolation (FR-009)
                velScale = velScale + (velocityOverlay_[velStep] - velScale) * spice_;
                // Gate: linear interpolation
                gateScale = gateScale + (gateOverlay_[gateStep] - gateScale) * spice_;
                // Ratchet: lerp + round to integer (FR-008)
                float ratchetBlend = static_cast<float>(ratchetCount)
                    + (static_cast<float>(ratchetOverlay_[ratchetStep])
                       - static_cast<float>(ratchetCount)) * spice_;
                ratchetCount = static_cast<uint8_t>(
                    std::clamp(static_cast<int>(std::round(ratchetBlend)), 1, 4));
                // Condition: threshold blend (FR-008)
                if (spice_ >= 0.5f) {
                    condValue = conditionOverlay_[condStep];
                }
            }

            // 076-conditional-trigs: detect loop count wrap (FR-011)
            // After advance, if position wrapped back to 0, the lane completed one cycle.
            // For length 1, this fires on every step (correct per FR-018).
            // The actual loopCount_ increment is deferred to AFTER condition evaluation
            // so that the current step evaluates against the pre-increment loopCount_.
            // This ensures First (loopCount_ == 0) fires on the very first step.
            const bool conditionLaneWrapped = (conditionLane_.currentStep() == 0);

            // --- 075-euclidean-timing: Euclidean gating check (FR-011, FR-012) ---
            // Evaluated AFTER all lane advances but BEFORE modifier evaluation.
            // All lanes above advance unconditionally on every step tick,
            // including Euclidean rest steps (FR-004, FR-011).
            if (euclideanEnabled_) {
                bool isHitStep = EuclideanPattern::isHit(
                    euclideanPattern_,
                    static_cast<int>(euclideanPosition_),
                    euclideanSteps_);

                // Advance position unconditionally (FR-012)
                euclideanPosition_ = (euclideanPosition_ + 1)
                    % static_cast<size_t>(euclideanSteps_);

                if (!isHitStep) {
                    // Euclidean rest path (FR-004, FR-006, FR-007):
                    // Cancel pending noteOffs to prevent double emission
                    cancelPendingNoteOffsForCurrentNotes();

                    // Emit noteOff for all currently sounding notes
                    for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                        outputEvents[eventCount++] = ArpEvent{
                            ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, sampleOffset};
                    }
                    currentArpNoteCount_ = 0;

                    // Break any active tie chain (FR-007)
                    tieActive_ = false;

                    // Increment swing step counter and recalculate duration
                    ++swingStepCounter_;
                    currentStepDuration_ = calculateStepDuration(ctx);

                    // 076-conditional-trigs: deferred loopCount_ increment (FR-011)
                    // Must happen even on Euclidean rest (condition not evaluated but
                    // loop counter still tracks lane cycles).
                    if (conditionLaneWrapped) {
                        ++loopCount_;
                    }
                    // 077-spice-dice-humanize: consume humanize PRNG on skipped step (FR-023)
                    (void)humanizeRng_.nextFloat();  // timing (discarded)
                    (void)humanizeRng_.nextFloat();  // velocity (discarded)
                    (void)humanizeRng_.nextFloat();  // gate (discarded)

                    // 081-interaction-polish: emit kSkip event (FR-007, FR-008)
                    if (eventCount < maxEvents) {
                        outputEvents[eventCount++] = ArpEvent{
                            ArpEvent::Type::kSkip,
                            static_cast<uint8_t>(velStep), 0, sampleOffset};
                    }
                    return;
                }
            }

            // --- 076-conditional-trigs: Condition evaluation (FR-012, FR-014) ---
            // Evaluated AFTER Euclidean gating but BEFORE modifier evaluation.
            // If condition fails, treat as rest (identical to Euclidean rest path).
            if (!evaluateCondition(condValue)) {
                // Condition-fail rest path: identical to Euclidean rest path
                cancelPendingNoteOffsForCurrentNotes();

                // Emit noteOff for all currently sounding notes
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, sampleOffset};
                }
                currentArpNoteCount_ = 0;

                // Break any active tie chain (FR-029)
                tieActive_ = false;

                // Increment swing step counter and recalculate duration
                ++swingStepCounter_;
                currentStepDuration_ = calculateStepDuration(ctx);

                // 076-conditional-trigs: deferred loopCount_ increment (FR-011)
                if (conditionLaneWrapped) {
                    ++loopCount_;
                }
                // 077-spice-dice-humanize: consume humanize PRNG on skipped step (FR-023)
                (void)humanizeRng_.nextFloat();  // timing (discarded)
                (void)humanizeRng_.nextFloat();  // velocity (discarded)
                (void)humanizeRng_.nextFloat();  // gate (discarded)

                // 081-interaction-polish: emit kSkip event (FR-007, FR-008)
                if (eventCount < maxEvents) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::kSkip,
                        static_cast<uint8_t>(velStep), 0, sampleOffset};
                }
                return;
            }

            // 076-conditional-trigs: deferred loopCount_ increment (FR-011)
            // Condition passed -- increment loop count if the lane wrapped this step.
            if (conditionLaneWrapped) {
                ++loopCount_;
            }

            // --- Modifier evaluation (073-per-step-mods) ---
            // Priority: Rest > Tie > Slide > Accent

            // Rest: kStepActive not set -> suppress noteOn, emit noteOff for previous
            if (!(modifierFlags & kStepActive)) {
                // Cancel pending noteOffs first to prevent double NoteOff emission
                // (emitDuePendingNoteOffs would otherwise re-emit for these notes)
                cancelPendingNoteOffsForCurrentNotes();

                // Emit noteOff for all currently sounding notes
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, sampleOffset};
                }
                currentArpNoteCount_ = 0;
                tieActive_ = false;

                // Increment swing step counter and recalculate duration
                ++swingStepCounter_;
                currentStepDuration_ = calculateStepDuration(ctx);
                // 077-spice-dice-humanize: consume humanize PRNG on skipped step (FR-023)
                (void)humanizeRng_.nextFloat();  // timing (discarded)
                (void)humanizeRng_.nextFloat();  // velocity (discarded)
                (void)humanizeRng_.nextFloat();  // gate (discarded)

                // 081-interaction-polish: emit kSkip event (FR-007, FR-008)
                if (eventCount < maxEvents) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::kSkip,
                        static_cast<uint8_t>(velStep), 0, sampleOffset};
                }
                return;
            }

            // Tie: kStepTie set -> sustain previous notes, no new noteOn (FR-011)
            if (modifierFlags & kStepTie) {
                if (currentArpNoteCount_ > 0) {
                    // Cancel pending noteOffs: tie overrides gate (FR-012)
                    cancelPendingNoteOffsForCurrentNotes();
                    tieActive_ = true;

                    // Increment swing step counter and recalculate duration
                    ++swingStepCounter_;
                    currentStepDuration_ = calculateStepDuration(ctx);
                    // 077-spice-dice-humanize: consume humanize PRNG on skipped step (FR-023, FR-024)
                    (void)humanizeRng_.nextFloat();  // timing (discarded)
                    (void)humanizeRng_.nextFloat();  // velocity (discarded)
                    (void)humanizeRng_.nextFloat();  // gate (discarded)
                    return;
                }
                // No preceding note -> behaves as rest (FR-013)
                tieActive_ = false;
                ++swingStepCounter_;
                currentStepDuration_ = calculateStepDuration(ctx);
                // 077-spice-dice-humanize: consume humanize PRNG on skipped step (FR-023, FR-024)
                (void)humanizeRng_.nextFloat();  // timing (discarded)
                (void)humanizeRng_.nextFloat();  // velocity (discarded)
                (void)humanizeRng_.nextFloat();  // gate (discarded)
                return;
            }

            // Active step (not Rest, not Tie): end any tie chain (FR-014)
            // If ending a tie chain, emit noteOffs for tie-sustained notes
            // before normal note emission (their pending noteOffs were cancelled).
            if (tieActive_) {
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, sampleOffset};
                }
                currentArpNoteCount_ = 0;
            }
            tieActive_ = false;

            // Slide evaluation (FR-015, FR-016, FR-017)
            // Determine if this is a slide step with a preceding sounding note
            bool isSlide = (modifierFlags & kStepSlide) != 0 && currentArpNoteCount_ > 0;

            // Apply velocity scaling to all notes in this step (FR-011)
            for (size_t i = 0; i < result.count; ++i) {
                int scaledVel = static_cast<int>(
                    std::round(result.velocities[i] * velScale));
                result.velocities[i] = static_cast<uint8_t>(
                    std::clamp(scaledVel, 1, 127));
            }

            // 074-ratcheting (FR-020): Capture pre-accent velocities for
            // subsequent sub-steps. Accent applies to first sub-step only;
            // remaining sub-steps use these un-accented velocities.
            std::array<uint8_t, 32> preAccentVelocities{};
            for (size_t i = 0; i < result.count && i < 32; ++i) {
                preAccentVelocities[i] = result.velocities[i];
            }

            // Accent: boost velocity after lane scaling (FR-019, FR-020)
            // Accent applies to any step that emits a noteOn (Active and Slide).
            // Rest and Tie return early above, so this code only runs for note-emitting steps.
            if ((modifierFlags & kStepAccent) && accentVelocity_ > 0) {
                for (size_t i = 0; i < result.count; ++i) {
                    int boosted = static_cast<int>(result.velocities[i]) + accentVelocity_;
                    result.velocities[i] = static_cast<uint8_t>(
                        std::clamp(boosted, 1, 127));
                }
            }

            // Apply pitch offset to all notes in this step (FR-017, FR-018)
            for (size_t i = 0; i < result.count; ++i) {
                int offsetNote = static_cast<int>(result.notes[i]) +
                                 static_cast<int>(pitchOffset);
                result.notes[i] = static_cast<uint8_t>(
                    std::clamp(offsetNote, 0, 127));
            }

            // 077-spice-dice-humanize: Humanize offsets (FR-014, FR-022 steps 11-14)
            // Always consume 3 PRNG values for deterministic advancement (FR-018)
            const float timingRand = humanizeRng_.nextFloat();    // [-1, 1]
            const float velocityRand = humanizeRng_.nextFloat();  // [-1, 1]
            const float gateRand = humanizeRng_.nextFloat();      // [-1, 1]

            // Compute humanized timing offset (FR-015)
            const int32_t maxTimingOffsetSamples =
                static_cast<int32_t>(sampleRate_ * 0.020f);  // 20ms
            int32_t timingOffsetSamples =
                static_cast<int32_t>(timingRand * static_cast<float>(maxTimingOffsetSamples) * humanize_);
            int32_t humanizedSampleOffset = std::clamp(
                sampleOffset + timingOffsetSamples,
                static_cast<int32_t>(0),
                static_cast<int32_t>(blockSize) - 1);

            // Compute humanized velocity offset (FR-016)
            int velocityOffset = static_cast<int>(velocityRand * 15.0f * humanize_);
            // Apply to all notes in result (after accent)
            for (size_t i = 0; i < result.count; ++i) {
                int humanizedVel = static_cast<int>(result.velocities[i]) + velocityOffset;
                result.velocities[i] = static_cast<uint8_t>(std::clamp(humanizedVel, 1, 127));
            }

            // Compute humanized gate offset ratio (FR-017, FR-021)
            float gateOffsetRatio = gateRand * 0.10f * humanize_;

            // Calculate gate duration with lane multiplier (FR-014)
            size_t gateDuration = calculateGateDuration(gateScale);
            // Apply humanize gate offset (FR-017)
            {
                int32_t humanizedGateDuration = static_cast<int32_t>(gateDuration)
                    + static_cast<int32_t>(static_cast<float>(gateDuration) * gateOffsetRatio);
                gateDuration = static_cast<size_t>(std::max(int32_t{1}, humanizedGateDuration));
            }

            // Peek at next modifier step: if the next step is a Tie or Slide step,
            // skip scheduling gate-based noteOffs so the notes sustain into
            // the next step (FR-012: Tie overrides gate; FR-015: Slide suppresses
            // previous noteOff to keep currentArpNoteCount_ > 0 for legato).
            uint8_t nextModFlags = modifierLane_.getStep(
                static_cast<size_t>(modifierLane_.currentStep()));
            bool nextStepIsTie = (nextModFlags & kStepActive) != 0 &&
                                 (nextModFlags & kStepTie) != 0;
            bool nextStepIsSlide = (nextModFlags & kStepActive) != 0 &&
                                   (nextModFlags & kStepSlide) != 0;
            bool suppressGateNoteOff = nextStepIsTie || nextStepIsSlide;

            // =================================================================
            // 074-ratcheting: Ratchet subdivision (FR-007 through FR-013)
            // =================================================================
            if (ratchetCount > 1) {
                // 078-ratchet-swing: compute per-sub-step durations with swing
                computeSwungSubStepDurations(currentStepDuration_, ratchetCount,
                                             gateScale, gateOffsetRatio);
                ratchetSubStepIndex_ = 0;
                ratchetTotalSubSteps_ = ratchetCount;

                // Emit first sub-step (sub-step 0) in fireStep.
                // Remaining sub-steps emitted by processBlock SubStep handler.

                // Slide handling for first sub-step (FR-019)
                if (isSlide) {
                    cancelPendingNoteOffsForCurrentNotes();
                }

                // Emit noteOffs for currently sounding notes (replace previous)
                if (!isSlide) {
                    for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                        outputEvents[eventCount++] = ArpEvent{
                            ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, sampleOffset};
                    }
                    currentArpNoteCount_ = 0;
                }

                // 077-spice-dice-humanize: Emit first sub-step noteOns at humanized offset (FR-019)
                for (size_t i = 0; i < result.count && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOn,
                        result.notes[i],
                        result.velocities[i],
                        humanizedSampleOffset,
                        isSlide};  // legato on first sub-step if Slide
                }

                // Track currently sounding notes
                for (size_t i = 0; i < result.count && i < 32; ++i) {
                    currentArpNotes_[i] = result.notes[i];
                }
                currentArpNoteCount_ = result.count < 32 ? result.count : 32;

                // Store ratchet state for remaining sub-steps (FR-011)
                ratchetSubStepCounter_ = 0;
                ratchetSubStepsRemaining_ = static_cast<uint8_t>(ratchetCount - 1);
                ratchetNoteCount_ = result.count < 32 ? result.count : 32;

                // Store note/velocity for sub-steps (FR-020: pre-accent velocity)
                // result.velocities has accent applied; subsequent sub-steps
                // use preAccentVelocities (velocity lane scaling only, no boost).
                if (result.count == 1) {
                    ratchetNote_ = result.notes[0];
                    ratchetVelocity_ = preAccentVelocities[0];
                }
                for (size_t i = 0; i < ratchetNoteCount_; ++i) {
                    ratchetNotes_[i] = result.notes[i];
                    ratchetVelocities_[i] = preAccentVelocities[i];
                }

                // Determine if next sub-step is the last (for look-ahead)
                ratchetIsLastSubStep_ = (ratchetSubStepsRemaining_ == 1);

                // Schedule gate noteOff for first sub-step (sub-step index 0)
                // First sub-step always schedules gate (look-ahead only on last sub-step)
                for (size_t i = 0; i < result.count; ++i) {
                    addPendingNoteOff(result.notes[i], ratchetGateDurations_[0],
                                       outputEvents, eventCount, maxEvents);
                }
            } else {
                // ratchetCount == 1: normal (Phase 5) note emission path
                ratchetSubStepsRemaining_ = 0;  // Ensure no stale sub-step state (FR-013)
                ratchetSubStepIndex_ = 0;

            if (isSlide) {
                // Slide: suppress previous noteOffs, emit legato noteOns (FR-015)
                cancelPendingNoteOffsForCurrentNotes();
                // Do NOT emit noteOffs for currently sounding notes

                if (result.count > 1) {
                    // Chord slide: emit legato noteOns for all new chord notes
                    for (size_t i = 0; i < result.count && eventCount < maxEvents; ++i) {
                        outputEvents[eventCount++] = ArpEvent{
                            ArpEvent::Type::NoteOn,
                            result.notes[i],
                            result.velocities[i],
                            humanizedSampleOffset,
                            true};  // legato=true
                    }
                    // Track all new chord notes as currently sounding
                    for (size_t i = 0; i < result.count && i < 32; ++i) {
                        currentArpNotes_[i] = result.notes[i];
                    }
                    currentArpNoteCount_ = result.count < 32 ? result.count : 32;
                } else {
                    // Single note slide
                    if (eventCount < maxEvents) {
                        outputEvents[eventCount++] = ArpEvent{
                            ArpEvent::Type::NoteOn,
                            result.notes[0],
                            result.velocities[0],
                            humanizedSampleOffset,
                            true};  // legato=true
                    }
                    // Replace the previous note tracking with the new note
                    currentArpNotes_[0] = result.notes[0];
                    currentArpNoteCount_ = 1;
                }

                // Schedule gate-based noteOffs for the new slide notes
                // (unless next step is Tie or Slide)
                if (!suppressGateNoteOff) {
                    for (size_t i = 0; i < result.count; ++i) {
                        addPendingNoteOff(result.notes[i], gateDuration, outputEvents,
                                           eventCount, maxEvents);
                    }
                }
            } else if (result.count > 1) {
                // FR-022: Chord mode -- emit NoteOff for all previously
                // sounding notes first (to replace the previous chord)
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, sampleOffset};
                }
                currentArpNoteCount_ = 0;

                // Emit NoteOn for ALL chord notes at the same humanized offset
                for (size_t i = 0; i < result.count && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOn,
                        result.notes[i],
                        result.velocities[i],
                        humanizedSampleOffset};
                }

                // Track all chord notes as currently sounding (FR-025)
                for (size_t i = 0; i < result.count && i < 32; ++i) {
                    currentArpNotes_[i] = result.notes[i];
                }
                currentArpNoteCount_ = result.count < 32 ? result.count : 32;

                // Schedule PendingNoteOff for each chord note (FR-026)
                // Skip if next step is Tie or Slide (FR-012, FR-015)
                if (!suppressGateNoteOff) {
                    for (size_t i = 0; i < result.count; ++i) {
                        addPendingNoteOff(result.notes[i], gateDuration, outputEvents,
                                           eventCount, maxEvents);
                    }
                }
            } else {
                // Single note path (result.count == 1)
                if (eventCount < maxEvents) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOn,
                        result.notes[0],
                        result.velocities[0],
                        humanizedSampleOffset};
                }

                // Track currently sounding note (FR-025)
                currentArpNotes_[currentArpNoteCount_] = result.notes[0];
                if (currentArpNoteCount_ < 32) {
                    ++currentArpNoteCount_;
                }

                // Schedule NoteOff for this note.
                // Skip if next step is Tie or Slide (FR-012, FR-015)
                if (!suppressGateNoteOff) {
                    addPendingNoteOff(result.notes[0], gateDuration, outputEvents,
                                       eventCount, maxEvents);
                }
            }
            } // end ratchetCount == 1 else branch
        } else {
            // result.count == 0: buffer became empty between steps (defensive).
            // Advance modifier lane in defensive branch too (FR-010)
            modifierLane_.advance();
            ratchetLane_.advance();          // 074-ratcheting: keep ratchet lane synchronized (FR-036)
            conditionLane_.advance();        // 076-conditional-trigs: keep condition lane synchronized (FR-037)
            // 076-conditional-trigs: check condition lane wrap for loopCount_ increment (FR-037)
            if (conditionLane_.currentStep() == 0) {
                ++loopCount_;
            }
            ratchetSubStepsRemaining_ = 0;   // 074-ratcheting: clear any pending sub-steps
            ratchetSubStepIndex_ = 0;

            // 075-euclidean-timing (FR-035): advance Euclidean position in
            // defensive branch to prevent desync with other lanes
            if (euclideanEnabled_) {
                euclideanPosition_ = (euclideanPosition_ + 1)
                    % static_cast<size_t>(euclideanSteps_);
            }

            // Treat as rest -- no NoteOn emitted. Emit NoteOff for any
            // currently sounding arp note to prevent stuck notes (FR-024).
            for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, sampleOffset};
            }
            currentArpNoteCount_ = 0;

            // 077-spice-dice-humanize: consume humanize PRNG in defensive branch (FR-041)
            (void)humanizeRng_.nextFloat();  // timing (discarded)
            (void)humanizeRng_.nextFloat();  // velocity (discarded)
            (void)humanizeRng_.nextFloat();  // gate (discarded)
        }

        // Increment swing step counter
        ++swingStepCounter_;

        // Recalculate step duration for next step (with swing).
        // 074-ratcheting: When ratchet sub-steps are pending (ratchetCount > 1),
        // do NOT recalculate. Keep currentStepDuration_ at the CURRENT step's
        // value so the step boundary timer fires at the correct time (end of
        // the current ratcheted step). The processBlock() Step handler
        // recalculates before calling fireStep() for the next step. (FR-025)
        if (ratchetSubStepsRemaining_ == 0) {
            currentStepDuration_ = calculateStepDuration(ctx);
        }
    }

    /// @brief Remove a note from the currentArpNotes_ tracking array.
    inline void removeFromCurrentArpNotes(uint8_t note) noexcept {
        for (size_t i = 0; i < currentArpNoteCount_; ++i) {
            if (currentArpNotes_[i] == note) {
                // Compact: move last to this slot
                currentArpNotes_[i] = currentArpNotes_[currentArpNoteCount_ - 1];
                --currentArpNoteCount_;
                return;
            }
        }
    }

    /// @brief Cancel all pending noteOffs for currently sounding notes.
    /// Used by Tie evaluation to override gate-based noteOff scheduling (FR-012).
    inline void cancelPendingNoteOffsForCurrentNotes() noexcept {
        for (size_t n = 0; n < currentArpNoteCount_; ++n) {
            uint8_t note = currentArpNotes_[n];
            // Remove all pending noteOffs matching this note
            size_t i = 0;
            while (i < pendingNoteOffCount_) {
                if (pendingNoteOffs_[i].note == note) {
                    pendingNoteOffs_[i] = pendingNoteOffs_[pendingNoteOffCount_ - 1];
                    --pendingNoteOffCount_;
                } else {
                    ++i;
                }
            }
        }
    }

    /// @brief Process pending NoteOffs for the entire block when no new steps fire.
    /// Used when heldNotes_ is empty but pending NoteOffs remain.
    inline void processPendingNoteOffsForBlock(
        size_t blockSize,
        std::span<ArpEvent> outputEvents,
        size_t& eventCount,
        size_t maxEvents) noexcept {
        // Process pending NoteOffs that fire within this block
        for (size_t i = 0; i < pendingNoteOffCount_;) {
            if (pendingNoteOffs_[i].samplesRemaining < blockSize &&
                eventCount < maxEvents) {
                int32_t offset = static_cast<int32_t>(
                    pendingNoteOffs_[i].samplesRemaining);
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOff,
                    pendingNoteOffs_[i].note,
                    0,
                    offset};
                removeFromCurrentArpNotes(pendingNoteOffs_[i].note);
                // Compact
                pendingNoteOffs_[i] = pendingNoteOffs_[pendingNoteOffCount_ - 1];
                --pendingNoteOffCount_;
            } else {
                pendingNoteOffs_[i].samplesRemaining -= blockSize;
                ++i;
            }
        }
    }

    // =========================================================================
    // Euclidean Pattern Helper (075-euclidean-timing, FR-008)
    // =========================================================================

    /// @brief Regenerate the Euclidean pattern bitmask from current parameters.
    /// Called by setters and constructor to keep euclideanPattern_ in sync.
    inline void regenerateEuclideanPattern() noexcept {
        euclideanPattern_ = EuclideanPattern::generate(
            euclideanHits_, euclideanSteps_, euclideanRotation_);
    }

    // =========================================================================
    // Lane Reset (072-independent-lanes)
    // =========================================================================

    /// @brief Reset all lane positions to step 0.
    /// Called from reset(), retrigger, and transport restart points.
    void resetLanes() noexcept {
        velocityLane_.reset();
        gateLane_.reset();
        pitchLane_.reset();
        modifierLane_.reset();   // 073-per-step-mods: reset modifier lane position
        tieActive_ = false;       // 073-per-step-mods: reset tie chain state
        ratchetLane_.reset();              // 074-ratcheting: reset ratchet lane position
        ratchetSubStepsRemaining_ = 0;     // 074-ratcheting: clear sub-step state
        ratchetSubStepCounter_ = 0;
        ratchetSubStepIndex_ = 0;
        euclideanPosition_ = 0;            // 075-euclidean-timing: reset Euclidean position (FR-013)
        conditionLane_.reset();              // 076-conditional-trigs: reset condition lane position
        loopCount_ = 0;                      // 076-conditional-trigs: reset loop counter
        // fillActive_ intentionally NOT reset (FR-022: performance control)
        // conditionRng_ intentionally NOT reset (FR-035: continuous randomness)
        // 077-spice-dice-humanize: overlays/Spice/Humanize intentionally NOT reset (FR-025-029)
        // velocityOverlay_, gateOverlay_, ratchetOverlay_, conditionOverlay_ preserved
        // spice_, humanize_ preserved (user-controlled parameters)
        // spiceDiceRng_, humanizeRng_ preserved (continuous randomness, like conditionRng_)
    }

    // =========================================================================
    // Composed Components (Layer 1)
    // =========================================================================

    HeldNoteBuffer heldNotes_;
    NoteSelector selector_{42};  ///< Seed 42 for deterministic random

    // =========================================================================
    // Lane Containers (072-independent-lanes, Layer 1)
    // =========================================================================

    ArpLane<float> velocityLane_;   ///< Velocity multiplier per step (default: length=1, step[0]=1.0f)
    ArpLane<float> gateLane_;       ///< Gate duration multiplier per step (default: length=1, step[0]=1.0f)
    ArpLane<int8_t> pitchLane_;    ///< Semitone offset per step (default: length=1, step[0]=0)
    ArpLane<uint8_t> modifierLane_; ///< Bitmask per step (default: length=1, step[0]=kStepActive)
    ArpLane<uint8_t> ratchetLane_;  ///< Per-step ratchet count 1-4 (default: length=1, step[0]=1)

    // =========================================================================
    // Modifier Configuration (073-per-step-mods)
    // =========================================================================

    int accentVelocity_{30};        ///< Additive velocity boost for accented steps (0-127)
    float slideTimeMs_{60.0f};      ///< Portamento duration (0-500ms). Stored for API symmetry.
    bool tieActive_{false};         ///< True when in a tie chain. Cleared by resetLanes().

    // =========================================================================
    // Ratchet Sub-Step State (074-ratcheting, FR-011)
    // =========================================================================

    uint8_t ratchetSubStepsRemaining_{0};      ///< Sub-steps left to fire (0 = inactive)
    std::array<size_t, 4> ratchetSubStepDurations_{}; ///< Per-sub-step durations in samples
    std::array<size_t, 4> ratchetGateDurations_{};    ///< Per-sub-step gate durations
    uint8_t ratchetSubStepIndex_{0};           ///< Which sub-step we're counting through
    uint8_t ratchetTotalSubSteps_{0};          ///< Total ratchet count for current step
    size_t ratchetSubStepCounter_{0};          ///< Sample counter within current sub-step
    uint8_t ratchetNote_{0};                   ///< MIDI note for retriggers (single note)
    uint8_t ratchetVelocity_{0};               ///< Non-accented velocity for retriggers
    bool ratchetIsLastSubStep_{false};         ///< True when firing last sub-step (for look-ahead)
    std::array<uint8_t, 32> ratchetNotes_{};   ///< Chord mode note numbers
    std::array<uint8_t, 32> ratchetVelocities_{}; ///< Chord mode velocities
    size_t ratchetNoteCount_{0};               ///< Chord mode note count
    float ratchetSwing_{0.50f};                ///< Ratchet swing ratio 0.50-0.75

    // =========================================================================
    // Euclidean Timing State (075-euclidean-timing, FR-001)
    // =========================================================================

    bool euclideanEnabled_{false};        ///< Whether Euclidean gating is active
    int euclideanHits_{4};                ///< Number of pulses (k), range [0, 32]
    int euclideanSteps_{8};               ///< Number of steps (n), range [2, 32]
    int euclideanRotation_{0};            ///< Rotation offset, range [0, 31]
    size_t euclideanPosition_{0};         ///< Current position in Euclidean pattern
    uint32_t euclideanPattern_{0};        ///< Pre-computed bitmask from generate()

    // =========================================================================
    // Condition State (076-conditional-trigs)
    // =========================================================================

    ArpLane<uint8_t> conditionLane_;     ///< Per-step condition (TrigCondition as uint8_t)
    size_t loopCount_{0};                ///< Condition lane cycle counter
    bool fillActive_{false};             ///< Fill mode performance toggle
    Xorshift32 conditionRng_{7919};      ///< Dedicated PRNG for probability (prime seed)

    // =========================================================================
    // Spice/Dice State (077-spice-dice-humanize)
    // =========================================================================

    /// Variation overlay arrays generated by triggerDice().
    /// Indexed by each lane's own step position (polymetric-aware).
    std::array<float, 32> velocityOverlay_{};    ///< [0.0, 1.0] velocity scaling
    std::array<float, 32> gateOverlay_{};        ///< [0.0, 1.0] gate scaling
    std::array<uint8_t, 32> ratchetOverlay_{};   ///< [1, 4] ratchet count
    std::array<uint8_t, 32> conditionOverlay_{}; ///< [0, 17] TrigCondition value

    float spice_{0.0f};                          ///< Blend amount [0, 1]
    float humanize_{0.0f};                       ///< Humanize amount [0, 1]
    Xorshift32 spiceDiceRng_{31337};             ///< PRNG for overlay generation
    Xorshift32 humanizeRng_{48271};              ///< PRNG for per-step offsets

    // =========================================================================
    // Configuration State
    // =========================================================================

    bool enabled_ = false;
    LatchMode latchMode_ = LatchMode::Off;
    ArpRetriggerMode retriggerMode_ = ArpRetriggerMode::Off;
    bool tempoSync_ = true;
    NoteValue noteValue_ = NoteValue::Eighth;
    NoteModifier noteModifier_ = NoteModifier::None;
    float freeRateHz_ = 4.0f;
    float gateLengthPercent_ = 80.0f;
    float swing_ = 0.0f;  ///< Stored as 0.0-0.75 (user-facing 0-75% divided by 100)

    // =========================================================================
    // Timing State
    // =========================================================================

    double sampleRate_ = 44100.0;
    size_t sampleCounter_ = 0;
    size_t currentStepDuration_ = 0;
    size_t swingStepCounter_ = 0;
    bool wasPlaying_ = false;
    bool firstStepPending_ = true;

    // =========================================================================
    // Latch State
    // =========================================================================

    size_t physicalKeysHeld_ = 0;
    bool latchActive_ = false;

    // =========================================================================
    // NoteOff Tracking (FR-025, FR-026)
    // =========================================================================

    std::array<uint8_t, 32> currentArpNotes_{};
    size_t currentArpNoteCount_ = 0;
    std::array<PendingNoteOff, 32> pendingNoteOffs_{};
    size_t pendingNoteOffCount_ = 0;

    // =========================================================================
    // Disable Transition (FR-008)
    // =========================================================================

    bool needsDisableNoteOff_ = false;
};

} // namespace Krate::DSP
