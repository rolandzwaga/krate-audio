// ==============================================================================
// Layer 2: Processor - ArpeggiatorCore (Timing & Event Generation)
// ==============================================================================
// Composes HeldNoteBuffer + NoteSelector (Layer 1) with integer sample-accurate
// timing to produce ArpEvent sequences. Header-only, zero heap allocation in
// all methods.
//
// Constitution Compliance:
// - Principle II: Real-Time Safety (noexcept, zero allocation, no locks, no IO)
// - Principle III: Modern C++ (C++20, enum class, constexpr, std::span)
// - Principle IX: Layer 2 (depends on Layer 0: BlockContext, NoteValue;
//                          Layer 1: HeldNoteBuffer, NoteSelector)
//
// Reference: specs/070-arpeggiator-core/spec.md
// ==============================================================================

#pragma once

#include <krate/dsp/core/block_context.h>
#include <krate/dsp/core/note_value.h>
#include <krate/dsp/primitives/arp_lane.h>
#include <krate/dsp/primitives/held_note_buffer.h>

#include <algorithm>
#include <array>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <span>

namespace Krate::DSP {

// =============================================================================
// Enumerations (FR-027, FR-028)
// =============================================================================

/// @brief How the arp handles key release.
enum class LatchMode : uint8_t {
    Off = 0,  ///< Stop when all keys released
    Hold,     ///< Continue playing latched pattern; new keys replace
    Add       ///< Accumulate notes into pattern
};

/// @brief When the arp pattern resets.
/// Named ArpRetriggerMode to avoid ODR conflict with RetriggerMode in envelope_utils.h.
enum class ArpRetriggerMode : uint8_t {
    Off = 0,  ///< Never auto-reset
    Note,     ///< Reset on each incoming noteOn
    Beat      ///< Reset at bar boundaries
};

// =============================================================================
// ArpEvent (FR-001, FR-002)
// =============================================================================

/// @brief A timestamped MIDI event generated by the arpeggiator.
struct ArpEvent {
    enum class Type : uint8_t { NoteOn, NoteOff };

    Type type{Type::NoteOn};
    uint8_t note{0};          ///< MIDI note number (0-127)
    uint8_t velocity{0};      ///< MIDI velocity (0-127)
    int32_t sampleOffset{0};  ///< Sample position within block [0, blockSize-1]
};

// =============================================================================
// ArpeggiatorCore (FR-003 through FR-032)
// =============================================================================

/// @brief Layer 2 DSP processor: arpeggiator timing and event generation.
///
/// Composes HeldNoteBuffer + NoteSelector (Layer 1) with integer timing
/// to produce sample-accurate ArpEvent sequences. Header-only, zero heap
/// allocation in all methods.
///
/// @par Real-Time Safety
/// All methods are noexcept. Zero heap allocation. No locks, exceptions, or I/O.
///
/// @par Usage
/// @code
/// ArpeggiatorCore arp;
/// arp.prepare(44100.0, 512);
/// arp.setEnabled(true);
/// arp.setMode(ArpMode::Up);
/// arp.setNoteValue(NoteValue::Eighth, NoteModifier::None);
/// arp.noteOn(60, 100);
/// arp.noteOn(64, 100);
///
/// std::array<ArpEvent, 64> events;
/// BlockContext ctx;
/// ctx.isPlaying = true;
/// size_t count = arp.processBlock(ctx, events);
/// @endcode
class ArpeggiatorCore {
public:
    // =========================================================================
    // Constants
    // =========================================================================

    static constexpr size_t kMaxEvents = 64;
    static constexpr size_t kMaxPendingNoteOffs = 32;
    static constexpr double kMinSampleRate = 1000.0;
    static constexpr float kMinFreeRate = 0.5f;
    static constexpr float kMaxFreeRate = 50.0f;
    static constexpr float kMinGateLength = 1.0f;
    static constexpr float kMaxGateLength = 200.0f;
    static constexpr float kMinSwing = 0.0f;
    static constexpr float kMaxSwing = 75.0f;

    // =========================================================================
    // Construction (072-independent-lanes: lane defaults for SC-002)
    // =========================================================================

    ArpeggiatorCore() noexcept {
        // Set velocity lane default: length=1, step[0]=1.0f (full passthrough)
        // This ensures SC-002 bit-identical backward compat from first use.
        velocityLane_.setStep(0, 1.0f);
        // Set gate lane default: length=1, step[0]=1.0f (pure global gate)
        gateLane_.setStep(0, 1.0f);
    }

    // =========================================================================
    // Lifecycle (FR-003, FR-004)
    // =========================================================================

    /// @brief Initialize for processing.
    /// @param sampleRate Sample rate in Hz (clamped to >= 1000)
    /// @param maxBlockSize Maximum block size (for validation)
    inline void prepare(double sampleRate,
                        [[maybe_unused]] size_t maxBlockSize) noexcept {
        sampleRate_ = (sampleRate >= kMinSampleRate) ? sampleRate : kMinSampleRate;
        reset();
    }

    /// @brief Reset all state to initial values. Configuration preserved.
    inline void reset() noexcept {
        sampleCounter_ = 0;
        currentStepDuration_ = 0;
        swingStepCounter_ = 0;
        wasPlaying_ = false;
        firstStepPending_ = true;
        currentArpNoteCount_ = 0;
        pendingNoteOffCount_ = 0;
        needsDisableNoteOff_ = false;
        physicalKeysHeld_ = 0;
        latchActive_ = false;
        selector_.reset();
        heldNotes_.clear();
        resetLanes();
    }

    // =========================================================================
    // MIDI Input (FR-005, FR-006, FR-007)
    // =========================================================================

    /// @brief Handle incoming MIDI note-on.
    /// Applies latch logic (replace vs accumulate) and retrigger logic.
    inline void noteOn(uint8_t note, uint8_t velocity) noexcept {
        ++physicalKeysHeld_;

        // Latch Hold: if currently latched (all keys were released), clear old
        // pattern and start fresh. This replaces the entire latched pattern.
        if (latchMode_ == LatchMode::Hold && latchActive_) {
            heldNotes_.clear();
            latchActive_ = false;
        }
        // Latch Add: always add, never clear (pattern accumulates)
        // Latch Off: standard behavior (just add)

        heldNotes_.noteOn(note, velocity);

        if (retriggerMode_ == ArpRetriggerMode::Note) {
            selector_.reset();
            swingStepCounter_ = 0;
            resetLanes();
        }
    }

    /// @brief Handle incoming MIDI note-off.
    /// Behavior depends on latch mode (remove, ignore, or track).
    inline void noteOff(uint8_t note) noexcept {
        if (physicalKeysHeld_ > 0) {
            --physicalKeysHeld_;
        }

        switch (latchMode_) {
            case LatchMode::Off:
                // Remove from held buffer
                heldNotes_.noteOff(note);
                // If buffer empty, signal that current arp note needs NoteOff
                if (heldNotes_.empty()) {
                    needsDisableNoteOff_ = true;
                }
                break;

            case LatchMode::Hold:
                // Do NOT remove from heldNotes_ -- notes remain for latched pattern.
                // When all physical keys are released, activate latch.
                if (physicalKeysHeld_ == 0) {
                    latchActive_ = true;
                }
                break;

            case LatchMode::Add:
                // Do NOT remove from heldNotes_ -- pattern accumulates indefinitely.
                break;
        }
    }

    // =========================================================================
    // Configuration (FR-008 through FR-018)
    // =========================================================================

    /// @brief Enable or disable the arpeggiator (FR-008).
    inline void setEnabled(bool enabled) noexcept {
        if (enabled_ && !enabled) {
            needsDisableNoteOff_ = true;
        }
        enabled_ = enabled;
    }

    /// @brief Set arp mode, delegating to NoteSelector (FR-009).
    /// Also resets swingStepCounter_ to 0 so next step gets even timing.
    inline void setMode(ArpMode mode) noexcept {
        selector_.setMode(mode);  // setMode() calls reset() internally
        swingStepCounter_ = 0;
    }

    /// @brief Set octave range 1-4, delegating to NoteSelector (FR-010).
    inline void setOctaveRange(int octaves) noexcept {
        selector_.setOctaveRange(std::clamp(octaves, 1, 4));
    }

    /// @brief Set octave traversal mode, delegating to NoteSelector (FR-011).
    inline void setOctaveMode(OctaveMode mode) noexcept {
        selector_.setOctaveMode(mode);
    }

    /// @brief Toggle tempo sync vs free rate mode (FR-012).
    inline void setTempoSync(bool sync) noexcept {
        tempoSync_ = sync;
    }

    /// @brief Set tempo-synced step rate (FR-013).
    inline void setNoteValue(NoteValue val, NoteModifier mod) noexcept {
        noteValue_ = val;
        noteModifier_ = mod;
    }

    /// @brief Set free-running rate in Hz, clamped 0.5-50.0 (FR-014).
    inline void setFreeRate(float hz) noexcept {
        freeRateHz_ = std::clamp(hz, kMinFreeRate, kMaxFreeRate);
    }

    /// @brief Set gate length as percentage 1-200% (FR-015).
    inline void setGateLength(float percent) noexcept {
        gateLengthPercent_ = std::clamp(percent, kMinGateLength, kMaxGateLength);
    }

    /// @brief Set swing as percentage 0-75% (FR-016).
    /// Stored internally as 0.0-0.75 (divided by 100).
    inline void setSwing(float percent) noexcept {
        float clamped = std::clamp(percent, kMinSwing, kMaxSwing);
        swing_ = clamped / 100.0f;
    }

    /// @brief Set latch mode (FR-017).
    inline void setLatchMode(LatchMode mode) noexcept {
        latchMode_ = mode;
    }

    /// @brief Set retrigger mode (FR-018).
    inline void setRetrigger(ArpRetriggerMode mode) noexcept {
        retriggerMode_ = mode;
    }

    // =========================================================================
    // Lane Accessors (072-independent-lanes, FR-010 through FR-024)
    // =========================================================================

    /// @brief Access velocity lane for configuration.
    ArpLane<float>& velocityLane() noexcept { return velocityLane_; }

    /// @brief Access velocity lane (const).
    [[nodiscard]] const ArpLane<float>& velocityLane() const noexcept {
        return velocityLane_;
    }

    /// @brief Access gate lane for configuration.
    ArpLane<float>& gateLane() noexcept { return gateLane_; }

    /// @brief Access gate lane (const).
    [[nodiscard]] const ArpLane<float>& gateLane() const noexcept {
        return gateLane_;
    }

    // =========================================================================
    // Processing (FR-019 through FR-024)
    // =========================================================================

    /// @brief Process one audio block, generating arp events.
    /// @param ctx Block context (tempo, sample rate, transport state)
    /// @param outputEvents Caller-owned span to receive events (capacity >= 64)
    /// @return Number of events written to outputEvents
    ///
    /// @pre outputEvents.size() >= kMaxEvents
    /// @post All events have sampleOffset in [0, ctx.blockSize-1]
    inline size_t processBlock(const BlockContext& ctx,
                               std::span<ArpEvent> outputEvents) noexcept {
        // (a) Zero blockSize guard (FR-032) -- no state change
        if (ctx.blockSize == 0) {
            return 0;
        }

        // Cap event emission to output span size
        const size_t maxEvents = (outputEvents.size() < kMaxEvents)
                                     ? outputEvents.size()
                                     : kMaxEvents;

        size_t eventCount = 0;

        // (c) Disabled check (FR-008)
        if (!enabled_) {
            if (needsDisableNoteOff_) {
                // Emit NoteOff for all currently sounding arp notes
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, 0};
                }
                // Emit all pending NoteOffs
                for (size_t i = 0; i < pendingNoteOffCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, pendingNoteOffs_[i].note, 0, 0};
                }
                currentArpNoteCount_ = 0;
                pendingNoteOffCount_ = 0;
                needsDisableNoteOff_ = false;
            }
            return eventCount;
        }

        // (d) Transport not playing check (FR-031)
        if (!ctx.isPlaying) {
            if (wasPlaying_) {
                // Transport just stopped -- emit NoteOffs for all currently
                // sounding arp notes at sampleOffset 0.
                // currentArpNotes_ tracks all notes with active gate;
                // pendingNoteOffs_ tracks the same notes' scheduled NoteOffs.
                // We emit from currentArpNotes_ only to avoid duplicates.
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, 0};
                }
                currentArpNoteCount_ = 0;
                pendingNoteOffCount_ = 0;
            }
            wasPlaying_ = false;
            return eventCount;
        }

        // Handle transport restart
        if (!wasPlaying_) {
            wasPlaying_ = true;
            firstStepPending_ = true;
            sampleCounter_ = 0;
        }

        // (g) firstStepPending_: compute initial step duration before loop
        if (firstStepPending_) {
            currentStepDuration_ = calculateStepDuration(ctx);
            firstStepPending_ = false;
        }

        // Empty buffer with latch Off: emit NoteOff for current arp notes,
        // flush all pending NoteOffs, then return (FR-007, FR-024)
        if (heldNotes_.empty()) {
            // If buffer just became empty (latch Off, all keys released),
            // emit NoteOff for currently sounding arp note(s) and flush
            // ALL pending NoteOffs at sampleOffset 0 to prevent stuck notes.
            if (needsDisableNoteOff_) {
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, 0};
                }
                // Flush all pending NoteOffs immediately at sampleOffset 0
                for (size_t i = 0; i < pendingNoteOffCount_ && eventCount < maxEvents; ++i) {
                    // Avoid duplicate: only emit if not already in currentArpNotes_
                    // (which we just emitted above). Since pending NoteOffs track
                    // notes that ARE in currentArpNotes_, skip duplicates.
                    bool alreadyEmitted = false;
                    for (size_t j = 0; j < currentArpNoteCount_; ++j) {
                        if (pendingNoteOffs_[i].note == currentArpNotes_[j]) {
                            alreadyEmitted = true;
                            break;
                        }
                    }
                    if (!alreadyEmitted) {
                        outputEvents[eventCount++] = ArpEvent{
                            ArpEvent::Type::NoteOff, pendingNoteOffs_[i].note, 0, 0};
                    }
                }
                currentArpNoteCount_ = 0;
                pendingNoteOffCount_ = 0;
                needsDisableNoteOff_ = false;
            }
            return eventCount;
        }

        // Retrigger Beat: detect bar boundary within this block (FR-023)
        // Compute once before the loop; store as samples-from-block-start.
        size_t barBoundaryOffset = SIZE_MAX;  // SIZE_MAX = no boundary
        if (retriggerMode_ == ArpRetriggerMode::Beat) {
            barBoundaryOffset = detectBarBoundary(ctx);
        }

        // Jump-ahead main loop
        size_t samplesProcessed = 0;
        const size_t blockSize = ctx.blockSize;

        while (samplesProcessed < blockSize && eventCount < maxEvents) {
            // How many samples until next step boundary?
            size_t samplesUntilStep = currentStepDuration_ - sampleCounter_;

            // Find minimum pending NoteOff samplesRemaining (relative to
            // samplesProcessed position)
            size_t samplesUntilNoteOff = SIZE_MAX;
            for (size_t i = 0; i < pendingNoteOffCount_; ++i) {
                if (pendingNoteOffs_[i].samplesRemaining < samplesUntilNoteOff) {
                    samplesUntilNoteOff = pendingNoteOffs_[i].samplesRemaining;
                }
            }

            // Retrigger Beat: how many samples until bar boundary?
            size_t samplesUntilBar = SIZE_MAX;
            if (barBoundaryOffset != SIZE_MAX &&
                barBoundaryOffset >= samplesProcessed) {
                samplesUntilBar = barBoundaryOffset - samplesProcessed;
            }

            // Jump to the minimum of (step boundary, pending NoteOff,
            // bar boundary, block end)
            size_t samplesUntilBlockEnd = blockSize - samplesProcessed;
            size_t jump = samplesUntilBlockEnd;  // default: consume to block end

            // Determine which event fires first
            enum class NextEvent { BlockEnd, NoteOff, Step, BarBoundary };
            NextEvent next = NextEvent::BlockEnd;

            if (samplesUntilStep <= jump) {
                jump = samplesUntilStep;
                next = NextEvent::Step;
            }
            if (samplesUntilNoteOff < jump ||
                (samplesUntilNoteOff == jump && next != NextEvent::Step)) {
                // NoteOff fires before or at same time as step (NoteOff before
                // NoteOn at same offset per FR-021)
                jump = samplesUntilNoteOff;
                next = NextEvent::NoteOff;
            }
            // If NoteOff and Step fire at the same sample, process NoteOff first
            // (FR-021 event ordering)
            if (samplesUntilNoteOff == samplesUntilStep &&
                samplesUntilStep <= samplesUntilBlockEnd) {
                next = NextEvent::NoteOff;
            }
            // Bar boundary: must fire before or at same time as step
            if (samplesUntilBar < jump) {
                jump = samplesUntilBar;
                next = NextEvent::BarBoundary;
            } else if (samplesUntilBar == jump && next == NextEvent::Step) {
                // Bar boundary and step at same sample: bar reset first
                next = NextEvent::BarBoundary;
            }

            // Advance time by jump amount
            sampleCounter_ += jump;
            samplesProcessed += jump;
            decrementPendingNoteOffs(jump);

            if (next == NextEvent::BlockEnd) {
                // No events fire -- we consumed the rest of the block
                break;
            }

            int32_t sampleOffset = static_cast<int32_t>(samplesProcessed);

            // Guard: if event fires exactly at blockSize, defer to next block
            if (samplesProcessed >= blockSize) {
                break;
            }

            if (next == NextEvent::BarBoundary) {
                // Bar boundary: reset selector and swing counter (FR-023)
                selector_.reset();
                swingStepCounter_ = 0;
                resetLanes();
                // Invalidate bar boundary so it doesn't fire again this block
                barBoundaryOffset = SIZE_MAX;

                // Emit any pending NoteOffs that are due at this sample
                emitDuePendingNoteOffs(sampleOffset, outputEvents, eventCount,
                                       maxEvents);

                // If step boundary also fires at this exact sample, process it
                if (sampleCounter_ >= currentStepDuration_) {
                    sampleCounter_ = 0;
                    // Recalculate step duration after swing reset
                    currentStepDuration_ = calculateStepDuration(ctx);
                    fireStep(ctx, sampleOffset, outputEvents, eventCount,
                             maxEvents, samplesProcessed, blockSize);
                } else {
                    // Recalculate current step duration with reset swing counter
                    currentStepDuration_ = calculateStepDuration(ctx);
                    // Adjust sampleCounter_ to reflect position within new step
                    // (the counter has been counting into the old step duration;
                    // keep the same elapsed count but against the new duration)
                }
            } else if (next == NextEvent::NoteOff) {
                // Emit all pending NoteOffs that are due at this sample
                emitDuePendingNoteOffs(sampleOffset, outputEvents, eventCount, maxEvents);

                // After emitting NoteOffs, check if step boundary also fires
                // at this exact sample
                if (sampleCounter_ >= currentStepDuration_) {
                    // Step fires at same offset -- process it
                    sampleCounter_ = 0;
                    fireStep(ctx, sampleOffset, outputEvents, eventCount, maxEvents,
                             samplesProcessed, blockSize);
                }
            } else if (next == NextEvent::Step) {
                // Step boundary reached
                sampleCounter_ = 0;

                // First emit any pending NoteOffs that are also due at this sample
                emitDuePendingNoteOffs(sampleOffset, outputEvents, eventCount, maxEvents);

                fireStep(ctx, sampleOffset, outputEvents, eventCount, maxEvents,
                         samplesProcessed, blockSize);
            }
        }

        // Decrement remaining pending NoteOffs by the unused portion of the block
        // (already handled by the jump-ahead loop consuming all samples)
        return eventCount;
    }

private:
    // =========================================================================
    // Internal Types
    // =========================================================================

    /// @brief Tracks a pending NoteOff that spans across block boundaries.
    struct PendingNoteOff {
        uint8_t note{0};
        size_t samplesRemaining{0};
    };

    // =========================================================================
    // Internal Methods
    // =========================================================================

    /// @brief Calculate step duration in samples from current settings.
    /// Uses double precision to avoid float * double precision loss.
    /// Returns at minimum 1 sample.
    inline size_t calculateStepDuration(const BlockContext& ctx) const noexcept {
        size_t baseDuration = 0;
        if (tempoSync_) {
            // (f) Double-precision: cast getBeatsForNote() to double before multiply
            double beatsPerStep = static_cast<double>(
                getBeatsForNote(noteValue_, noteModifier_));
            double secondsPerBeat = 60.0 / ctx.tempoBPM;
            baseDuration = static_cast<size_t>(
                secondsPerBeat * beatsPerStep * ctx.sampleRate);
        } else {
            baseDuration = static_cast<size_t>(sampleRate_ / static_cast<double>(freeRateHz_));
        }

        // Apply swing
        size_t swungDuration = baseDuration;
        if (swing_ > 0.0f) {
            double swingVal = static_cast<double>(swing_);
            if (swingStepCounter_ % 2 == 0) {
                // Even step: lengthen
                swungDuration = static_cast<size_t>(
                    static_cast<double>(baseDuration) * (1.0 + swingVal));
            } else {
                // Odd step: shorten
                swungDuration = static_cast<size_t>(
                    static_cast<double>(baseDuration) * (1.0 - swingVal));
            }
        }

        // Clamp to minimum 1 sample
        return (swungDuration > 0) ? swungDuration : 1;
    }

    /// @brief Detect if a bar boundary falls within the current block.
    /// @return Offset within block (0 to blockSize-1) of the bar boundary,
    ///         or SIZE_MAX if no bar boundary falls within this block.
    /// Uses ctx.transportPositionSamples and ctx.samplesPerBar() (FR-023).
    inline size_t detectBarBoundary(const BlockContext& ctx) const noexcept {
        const size_t barSamples = ctx.samplesPerBar();
        if (barSamples == 0) {
            return SIZE_MAX;  // Prevent division by zero
        }

        const int64_t blockStart = ctx.transportPositionSamples;
        if (blockStart < 0) {
            return SIZE_MAX;  // Invalid transport position
        }

        const int64_t barSamplesI64 = static_cast<int64_t>(barSamples);
        const int64_t remainder = blockStart % barSamplesI64;

        int64_t barBoundarySample = 0;
        if (remainder == 0) {
            // Block starts exactly at a bar boundary
            barBoundarySample = 0;
        } else {
            // Next bar boundary is barSamples - remainder into the block
            barBoundarySample = barSamplesI64 - remainder;
        }

        // Check if bar boundary falls within [0, blockSize)
        if (barBoundarySample >= 0 &&
            barBoundarySample < static_cast<int64_t>(ctx.blockSize)) {
            return static_cast<size_t>(barBoundarySample);
        }

        return SIZE_MAX;  // No bar boundary in this block
    }

    /// @brief Calculate gate duration in samples from current step duration.
    /// Gate duration = stepDuration * gateLengthPercent / 100 * gateLaneValue,
    /// clamped to minimum 1 sample (FR-014: ensures NoteOff always fires).
    /// @param gateLaneValue Gate lane multiplier (default 1.0f for backward compat)
    inline size_t calculateGateDuration(float gateLaneValue = 1.0f) const noexcept {
        return std::max(size_t{1}, static_cast<size_t>(
            static_cast<double>(currentStepDuration_) *
            static_cast<double>(gateLengthPercent_) / 100.0 *
            static_cast<double>(gateLaneValue)));
    }

    /// @brief Decrement all pending NoteOff samplesRemaining by given amount.
    inline void decrementPendingNoteOffs(size_t samples) noexcept {
        for (size_t i = 0; i < pendingNoteOffCount_; ++i) {
            if (pendingNoteOffs_[i].samplesRemaining >= samples) {
                pendingNoteOffs_[i].samplesRemaining -= samples;
            } else {
                pendingNoteOffs_[i].samplesRemaining = 0;
            }
        }
    }

    /// @brief Emit all pending NoteOffs whose samplesRemaining == 0.
    /// Removes them from the array by compacting.
    inline void emitDuePendingNoteOffs(int32_t sampleOffset,
                                        std::span<ArpEvent> outputEvents,
                                        size_t& eventCount,
                                        size_t maxEvents) noexcept {
        size_t i = 0;
        while (i < pendingNoteOffCount_ && eventCount < maxEvents) {
            if (pendingNoteOffs_[i].samplesRemaining == 0) {
                // Emit NoteOff event
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOff,
                    pendingNoteOffs_[i].note,
                    0,
                    sampleOffset};

                // Remove from currentArpNotes_ tracking
                removeFromCurrentArpNotes(pendingNoteOffs_[i].note);

                // Compact: move last element to this slot
                pendingNoteOffs_[i] = pendingNoteOffs_[pendingNoteOffCount_ - 1];
                --pendingNoteOffCount_;
                // Don't increment i -- re-check the swapped element
            } else {
                ++i;
            }
        }
    }

    /// @brief Add a pending NoteOff to the array.
    /// If at capacity, emit the oldest one at sampleOffset 0 (overflow handling).
    inline void addPendingNoteOff(uint8_t note, size_t samplesRemaining,
                                   std::span<ArpEvent> outputEvents,
                                   size_t& eventCount,
                                   size_t maxEvents) noexcept {
        if (pendingNoteOffCount_ >= kMaxPendingNoteOffs) {
            // Overflow: emit oldest (first entry) at sampleOffset 0
            if (eventCount < maxEvents) {
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOff,
                    pendingNoteOffs_[0].note,
                    0,
                    0};
                removeFromCurrentArpNotes(pendingNoteOffs_[0].note);
            }
            // Compact: shift everything down
            for (size_t i = 1; i < pendingNoteOffCount_; ++i) {
                pendingNoteOffs_[i - 1] = pendingNoteOffs_[i];
            }
            --pendingNoteOffCount_;
        }

        pendingNoteOffs_[pendingNoteOffCount_] = PendingNoteOff{note, samplesRemaining};
        ++pendingNoteOffCount_;
    }

    /// @brief Fire a step: advance NoteSelector, emit NoteOn, schedule NoteOff.
    inline void fireStep(const BlockContext& ctx,
                          int32_t sampleOffset,
                          std::span<ArpEvent> outputEvents,
                          size_t& eventCount,
                          size_t maxEvents,
                          [[maybe_unused]] size_t samplesProcessed,
                          [[maybe_unused]] size_t blockSize) noexcept {
        // Advance NoteSelector to get next note(s)
        ArpNoteResult result = selector_.advance(heldNotes_);

        if (result.count > 0) {
            // Advance lanes (once per step, regardless of chord size)
            float velScale = velocityLane_.advance();
            float gateScale = gateLane_.advance();

            // Apply velocity scaling to all notes in this step (FR-011)
            for (size_t i = 0; i < result.count; ++i) {
                int scaledVel = static_cast<int>(
                    std::round(result.velocities[i] * velScale));
                result.velocities[i] = static_cast<uint8_t>(
                    std::clamp(scaledVel, 1, 127));
            }

            // Calculate gate duration with lane multiplier (FR-014)
            size_t gateDuration = calculateGateDuration(gateScale);

            if (result.count > 1) {
                // FR-022: Chord mode -- emit NoteOff for all previously
                // sounding notes first (to replace the previous chord)
                for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, sampleOffset};
                }
                currentArpNoteCount_ = 0;

                // Emit NoteOn for ALL chord notes at the same sampleOffset
                for (size_t i = 0; i < result.count && eventCount < maxEvents; ++i) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOn,
                        result.notes[i],
                        result.velocities[i],
                        sampleOffset};
                }

                // Track all chord notes as currently sounding (FR-025)
                for (size_t i = 0; i < result.count && i < 32; ++i) {
                    currentArpNotes_[i] = result.notes[i];
                }
                currentArpNoteCount_ = result.count < 32 ? result.count : 32;

                // Schedule PendingNoteOff for each chord note (FR-026)
                for (size_t i = 0; i < result.count; ++i) {
                    addPendingNoteOff(result.notes[i], gateDuration, outputEvents,
                                       eventCount, maxEvents);
                }
            } else {
                // Single note path (result.count == 1)
                if (eventCount < maxEvents) {
                    outputEvents[eventCount++] = ArpEvent{
                        ArpEvent::Type::NoteOn,
                        result.notes[0],
                        result.velocities[0],
                        sampleOffset};
                }

                // Track currently sounding note (FR-025)
                currentArpNotes_[currentArpNoteCount_] = result.notes[0];
                if (currentArpNoteCount_ < 32) {
                    ++currentArpNoteCount_;
                }

                // Schedule NoteOff for this note.
                addPendingNoteOff(result.notes[0], gateDuration, outputEvents,
                                   eventCount, maxEvents);
            }
        } else {
            // result.count == 0: buffer became empty between steps (defensive).
            // Treat as rest -- no NoteOn emitted. Emit NoteOff for any
            // currently sounding arp note to prevent stuck notes (FR-024).
            for (size_t i = 0; i < currentArpNoteCount_ && eventCount < maxEvents; ++i) {
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOff, currentArpNotes_[i], 0, sampleOffset};
            }
            currentArpNoteCount_ = 0;
        }

        // Increment swing step counter
        ++swingStepCounter_;

        // Recalculate step duration for next step (with swing)
        currentStepDuration_ = calculateStepDuration(ctx);
    }

    /// @brief Remove a note from the currentArpNotes_ tracking array.
    inline void removeFromCurrentArpNotes(uint8_t note) noexcept {
        for (size_t i = 0; i < currentArpNoteCount_; ++i) {
            if (currentArpNotes_[i] == note) {
                // Compact: move last to this slot
                currentArpNotes_[i] = currentArpNotes_[currentArpNoteCount_ - 1];
                --currentArpNoteCount_;
                return;
            }
        }
    }

    /// @brief Process pending NoteOffs for the entire block when no new steps fire.
    /// Used when heldNotes_ is empty but pending NoteOffs remain.
    inline void processPendingNoteOffsForBlock(
        size_t blockSize,
        std::span<ArpEvent> outputEvents,
        size_t& eventCount,
        size_t maxEvents) noexcept {
        // Process pending NoteOffs that fire within this block
        for (size_t i = 0; i < pendingNoteOffCount_;) {
            if (pendingNoteOffs_[i].samplesRemaining < blockSize &&
                eventCount < maxEvents) {
                int32_t offset = static_cast<int32_t>(
                    pendingNoteOffs_[i].samplesRemaining);
                outputEvents[eventCount++] = ArpEvent{
                    ArpEvent::Type::NoteOff,
                    pendingNoteOffs_[i].note,
                    0,
                    offset};
                removeFromCurrentArpNotes(pendingNoteOffs_[i].note);
                // Compact
                pendingNoteOffs_[i] = pendingNoteOffs_[pendingNoteOffCount_ - 1];
                --pendingNoteOffCount_;
            } else {
                pendingNoteOffs_[i].samplesRemaining -= blockSize;
                ++i;
            }
        }
    }

    // =========================================================================
    // Lane Reset (072-independent-lanes)
    // =========================================================================

    /// @brief Reset all lane positions to step 0.
    /// Called from reset(), retrigger, and transport restart points.
    void resetLanes() noexcept {
        velocityLane_.reset();
        gateLane_.reset();
    }

    // =========================================================================
    // Composed Components (Layer 1)
    // =========================================================================

    HeldNoteBuffer heldNotes_;
    NoteSelector selector_{42};  ///< Seed 42 for deterministic random

    // =========================================================================
    // Lane Containers (072-independent-lanes, Layer 1)
    // =========================================================================

    ArpLane<float> velocityLane_;   ///< Velocity multiplier per step (default: length=1, step[0]=1.0f)
    ArpLane<float> gateLane_;       ///< Gate duration multiplier per step (default: length=1, step[0]=1.0f)

    // =========================================================================
    // Configuration State
    // =========================================================================

    bool enabled_ = false;
    LatchMode latchMode_ = LatchMode::Off;
    ArpRetriggerMode retriggerMode_ = ArpRetriggerMode::Off;
    bool tempoSync_ = true;
    NoteValue noteValue_ = NoteValue::Eighth;
    NoteModifier noteModifier_ = NoteModifier::None;
    float freeRateHz_ = 4.0f;
    float gateLengthPercent_ = 80.0f;
    float swing_ = 0.0f;  ///< Stored as 0.0-0.75 (user-facing 0-75% divided by 100)

    // =========================================================================
    // Timing State
    // =========================================================================

    double sampleRate_ = 44100.0;
    size_t sampleCounter_ = 0;
    size_t currentStepDuration_ = 0;
    size_t swingStepCounter_ = 0;
    bool wasPlaying_ = false;
    bool firstStepPending_ = true;

    // =========================================================================
    // Latch State
    // =========================================================================

    size_t physicalKeysHeld_ = 0;
    bool latchActive_ = false;

    // =========================================================================
    // NoteOff Tracking (FR-025, FR-026)
    // =========================================================================

    std::array<uint8_t, 32> currentArpNotes_{};
    size_t currentArpNoteCount_ = 0;
    std::array<PendingNoteOff, 32> pendingNoteOffs_{};
    size_t pendingNoteOffCount_ = 0;

    // =========================================================================
    // Disable Transition (FR-008)
    // =========================================================================

    bool needsDisableNoteOff_ = false;
};

} // namespace Krate::DSP
