name: Release

# ==============================================================================
# Multi-Plugin Release Workflow
# ==============================================================================
# This workflow releases individual plugins from the Krate Audio monorepo.
#
# HOW TO ADD A NEW PLUGIN:
# 1. Add the plugin name (lowercase) to the 'options' list below
# 2. Create plugins/{name}/version.json with required fields:
#    {
#      "name": "PluginName",        // Display name (e.g., "Iterum")
#      "version": "1.0.0",          // Semantic version
#      "description": "...",        // One-line description
#      "publisher": "Krate Audio",  // Publisher name
#      "url": "https://...",        // Plugin homepage
#      "identifier": "com.krateaudio.pluginname"  // Optional, for macOS pkg
#    }
# 3. Ensure CI workflow builds the plugin (update ci.yml if needed)
# 4. Create installer scripts in plugins/{name}/installers/
#
# TAG FORMAT: {plugin}/v{version} (e.g., iterum/v0.8.0)
# ==============================================================================

# Manual trigger with plugin selection
on:
  workflow_dispatch:
    inputs:
      plugin:
        description: 'Plugin to release'
        type: choice
        required: true
        # Add new plugins here (lowercase directory name)
        options:
          - iterum
          - disrumpo
        default: iterum
      prerelease:
        description: 'Mark as pre-release?'
        type: boolean
        default: false

# Prevent duplicate runs
concurrency:
  group: release-${{ inputs.plugin }}
  cancel-in-progress: false

jobs:
  # Read version and compute plugin metadata
  version:
    name: Get Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      plugin: ${{ steps.version.outputs.plugin }}
      plugin_name: ${{ steps.version.outputs.plugin_name }}
      has_landing_page: ${{ steps.version.outputs.has_landing_page }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Read Version
        id: version
        run: |
          PLUGIN="${{ inputs.plugin }}"
          VERSION=$(jq -r '.version' plugins/${PLUGIN}/version.json)
          PLUGIN_NAME=$(jq -r '.name' plugins/${PLUGIN}/version.json)
          TAG="${PLUGIN}/v${VERSION}"

          echo "plugin=$PLUGIN" >> $GITHUB_OUTPUT
          echo "plugin_name=$PLUGIN_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

          # Check if plugin has a landing page template
          if [ -f "plugins/${PLUGIN}/docs/index.html" ]; then
            echo "has_landing_page=true" >> $GITHUB_OUTPUT
          else
            echo "has_landing_page=false" >> $GITHUB_OUTPUT
          fi

          echo "Release: $PLUGIN_NAME v$VERSION (tag: $TAG)"

  # Build and test on all platforms using the CI workflow
  build:
    name: Build & Test
    needs: version
    uses: ./.github/workflows/ci.yml

  # Generate factory presets using the preset generator tool
  generate-presets:
    name: Generate Presets
    needs: [version, build]
    runs-on: ubuntu-latest

    env:
      CCACHE_MAXSIZE: 200M
      CCACHE_COMPRESS: true
      CCACHE_COMPRESSLEVEL: 6

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # Cache apt packages (same as CI Linux build)
      - name: Cache apt packages
        uses: awalsh128/cache-apt-pkgs-action@latest
        with:
          packages: >-
            ninja-build libx11-dev libxcb1-dev libxkbcommon-x11-dev libx11-xcb-dev
            libxcb-util1 libxcb-util-dev libxcb-keysyms1-dev libxcb-cursor-dev
            libxcb-xkb-dev libxkbcommon-dev libfontconfig1-dev libfreetype6-dev
            libcairo2-dev libgtkmm-3.0-dev libsqlite3-dev
          version: 1.0

      # Cache ccache data
      - name: Setup ccache
        uses: hendrikmuhs/ccache-action@v1.2
        with:
          key: linux-gcc-preset-generator
          max-size: ${{ env.CCACHE_MAXSIZE }}

      # Cache CMake FetchContent downloads
      - name: Cache FetchContent
        uses: actions/cache@v4
        with:
          path: build/_deps
          key: fetchcontent-${{ github.repository }}-${{ runner.os }}-${{ hashFiles('CMakeLists.txt', 'dsp/CMakeLists.txt', 'plugins/iterum/CMakeLists.txt', 'plugins/disrumpo/CMakeLists.txt', 'tests/CMakeLists.txt') }}
          restore-keys: |
            fetchcontent-${{ github.repository }}-${{ runner.os }}-

      - name: Configure CMake
        run: |
          cmake -S . -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_C_COMPILER_LAUNCHER=ccache \
            -DCMAKE_CXX_COMPILER_LAUNCHER=ccache

      - name: Determine Preset Generator
        id: gen
        env:
          PLUGIN: ${{ needs.version.outputs.plugin }}
        run: |
          # Map plugin to its CMake preset generator target
          # (iterum uses 'preset_generator', others use '{plugin}_preset_generator')
          case "$PLUGIN" in
            iterum)
              echo "target=preset_generator" >> $GITHUB_OUTPUT
              echo "binary=preset_generator" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "target=${PLUGIN}_preset_generator" >> $GITHUB_OUTPUT
              echo "binary=${PLUGIN}_preset_generator" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Build Preset Generator
        run: cmake --build build --target ${{ steps.gen.outputs.target }} --parallel

      - name: Generate Presets
        run: |
          mkdir -p generated-presets
          ./build/bin/${{ steps.gen.outputs.binary }} generated-presets

      - name: Upload Presets
        uses: actions/upload-artifact@v4
        with:
          name: factory-presets
          path: generated-presets/
          if-no-files-found: error

  # Windows installer using Inno Setup
  windows-installer:
    name: Windows Installer
    needs: [version, build, generate-presets]
    runs-on: windows-latest
    permissions:
      actions: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Windows Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.version.outputs.plugin_name }}-Windows-x64
          path: artifact
          github-token: ${{ github.token }}

      - name: Download Factory Presets
        uses: actions/download-artifact@v4
        with:
          name: factory-presets
          path: presets
          github-token: ${{ github.token }}

      - name: List Downloaded Artifacts
        run: |
          Write-Host "=== Plugin Artifact ==="
          Get-ChildItem -Recurse artifact | Format-Table FullName
          Write-Host "=== Factory Presets ==="
          Get-ChildItem -Recurse presets | Format-Table FullName

      - name: Prepare Installer Files
        env:
          PLUGIN: ${{ needs.version.outputs.plugin }}
          PLUGIN_NAME: ${{ needs.version.outputs.plugin_name }}
        run: |
          # Rename artifact folder to Plugin.vst3 (upload-artifact extracts contents, not folder)
          Rename-Item -Path "artifact" -NewName "${env:PLUGIN_NAME}.vst3"
          Move-Item -Path "${env:PLUGIN_NAME}.vst3" -Destination "plugins\${env:PLUGIN}\installers\windows\"
          # Copy freshly generated factory presets
          Copy-Item -Path "presets" -Destination "plugins\${env:PLUGIN}\installers\windows\" -Recurse
          # Convert markdown to plain text for installer display
          (Get-Content "plugins\${env:PLUGIN}\CHANGELOG.md" -Raw) `
            -replace '\[([^\]]+)\]\([^\)]+\)', '$1' `
            -replace '\*\*([^\*]+)\*\*', '$1' `
            -replace '`([^`]+)`', '$1' `
            -replace '^#{1,3}\s*', '' `
            | Set-Content "plugins\${env:PLUGIN}\installers\windows\CHANGELOG.txt"

      - name: Build Installer
        uses: Minionguyjpro/Inno-Setup-Action@v1.2.2
        with:
          path: plugins/${{ needs.version.outputs.plugin }}/installers/windows/setup.iss
          options: /DVersion=${{ needs.version.outputs.version }}

      - name: Upload Installer
        uses: actions/upload-artifact@v4
        with:
          name: windows-installer
          path: plugins/${{ needs.version.outputs.plugin }}/installers/windows/${{ needs.version.outputs.plugin_name }}-${{ needs.version.outputs.version }}-Windows-x64.exe
          if-no-files-found: error

  # macOS installer using pkgbuild
  macos-installer:
    name: macOS Installer
    needs: [version, build, generate-presets]
    runs-on: macos-latest
    permissions:
      actions: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download macOS Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.version.outputs.plugin_name }}-macOS
          path: artifact
          github-token: ${{ github.token }}

      - name: Download Factory Presets
        uses: actions/download-artifact@v4
        with:
          name: factory-presets
          path: presets
          github-token: ${{ github.token }}

      - name: List Downloaded Artifacts
        run: |
          echo "=== Plugin Artifact ==="
          ls -laR artifact
          echo "=== Factory Presets ==="
          ls -laR presets

      - name: Prepare Installer Files
        env:
          PLUGIN: ${{ needs.version.outputs.plugin }}
          PLUGIN_NAME: ${{ needs.version.outputs.plugin_name }}
        run: |
          # Create staging directories for both VST3 and AU
          mkdir -p staging/Library/Audio/Plug-Ins/VST3
          mkdir -p staging/Library/Audio/Plug-Ins/Components
          # Move VST3 and AU bundles to appropriate locations
          mv artifact/${PLUGIN_NAME}.vst3 staging/Library/Audio/Plug-Ins/VST3/
          mv artifact/${PLUGIN_NAME}.component staging/Library/Audio/Plug-Ins/Components/
          # Create factory presets directory and copy freshly generated presets
          mkdir -p "staging/Library/Application Support/Krate Audio/${PLUGIN_NAME}"
          cp -r presets/* "staging/Library/Application Support/Krate Audio/${PLUGIN_NAME}/"

      - name: Build Installer
        env:
          PLUGIN: ${{ needs.version.outputs.plugin }}
          PLUGIN_NAME: ${{ needs.version.outputs.plugin_name }}
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          # Read identifier from version.json or use default
          IDENTIFIER=$(jq -r '.identifier // "com.krateaudio.\(.name | ascii_downcase)"' plugins/${PLUGIN}/version.json)
          pkgbuild \
            --root staging \
            --identifier "$IDENTIFIER" \
            --version "$VERSION" \
            --install-location / \
            "${PLUGIN_NAME}-${VERSION}-macOS.pkg"

      - name: Upload Installer
        uses: actions/upload-artifact@v4
        with:
          name: macos-installer
          path: ${{ needs.version.outputs.plugin_name }}-${{ needs.version.outputs.version }}-macOS.pkg
          if-no-files-found: error

  # Linux archive with README
  linux-archive:
    name: Linux Archive
    needs: [version, build, generate-presets]
    runs-on: ubuntu-latest
    permissions:
      actions: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Linux Artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.version.outputs.plugin_name }}-Linux-x64
          path: artifact
          github-token: ${{ github.token }}

      - name: Download Factory Presets
        uses: actions/download-artifact@v4
        with:
          name: factory-presets
          path: presets
          github-token: ${{ github.token }}

      - name: List Downloaded Artifacts
        run: |
          echo "=== Plugin Artifact ==="
          ls -laR artifact
          echo "=== Factory Presets ==="
          ls -laR presets

      - name: Prepare Archive Files
        env:
          PLUGIN: ${{ needs.version.outputs.plugin }}
          PLUGIN_NAME: ${{ needs.version.outputs.plugin_name }}
        run: |
          mkdir -p staging
          # Rename artifact folder to Plugin.vst3 (upload-artifact extracts contents, not folder)
          mv artifact staging/${PLUGIN_NAME}.vst3
          # Copy freshly generated factory presets
          cp -r presets staging/
          cp plugins/${PLUGIN}/installers/linux/README.txt staging/
          # Convert markdown to plain text
          sed -e 's/\[\([^]]*\)\]([^)]*)/ \1/g' \
              -e 's/\*\*\([^*]*\)\*\*/\1/g' \
              -e 's/`\([^`]*\)`/\1/g' \
              -e 's/^#\{1,3\} *//' \
              plugins/${PLUGIN}/CHANGELOG.md > staging/CHANGELOG.txt

      - name: Create Archive
        env:
          PLUGIN_NAME: ${{ needs.version.outputs.plugin_name }}
          VERSION: ${{ needs.version.outputs.version }}
        run: |
          cd staging
          tar -czvf ../${PLUGIN_NAME}-${VERSION}-Linux-x64.tar.gz *

      - name: Upload Archive
        uses: actions/upload-artifact@v4
        with:
          name: linux-archive
          path: ${{ needs.version.outputs.plugin_name }}-${{ needs.version.outputs.version }}-Linux-x64.tar.gz
          if-no-files-found: error

  # Create GitHub Release with all installers (creates tag automatically)
  release:
    name: Create Release
    needs: [version, windows-installer, macos-installer, linux-archive]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      release_url: ${{ steps.release.outputs.url }}

    steps:
      - name: Download Windows Installer
        uses: actions/download-artifact@v4
        with:
          name: windows-installer
          path: installers

      - name: Download macOS Installer
        uses: actions/download-artifact@v4
        with:
          name: macos-installer
          path: installers

      - name: Download Linux Archive
        uses: actions/download-artifact@v4
        with:
          name: linux-archive
          path: installers

      - name: List Installers
        run: ls -la installers/

      # Create GitHub Release and tag
      - name: Create Release
        id: release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.version.outputs.tag }}
          name: ${{ needs.version.outputs.plugin_name }} ${{ needs.version.outputs.tag }}
          draft: false
          prerelease: ${{ inputs.prerelease }}
          generate_release_notes: true
          files: |
            installers/${{ needs.version.outputs.plugin_name }}-${{ needs.version.outputs.version }}-Windows-x64.exe
            installers/${{ needs.version.outputs.plugin_name }}-${{ needs.version.outputs.version }}-macOS.pkg
            installers/${{ needs.version.outputs.plugin_name }}-${{ needs.version.outputs.version }}-Linux-x64.tar.gz

  # Deploy plugin landing page to GitHub Pages (incremental via gh-pages branch)
  # Each release updates only its plugin subdirectory and regenerates the root index.
  # Other plugins' pages are preserved via keep_files.
  deploy-pages:
    name: Deploy Landing Page
    needs: [version, release]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Generate Plugin Landing Page
        if: needs.version.outputs.has_landing_page == 'true'
        env:
          PLUGIN: ${{ needs.version.outputs.plugin }}
          PLUGIN_NAME: ${{ needs.version.outputs.plugin_name }}
          VERSION: ${{ needs.version.outputs.version }}
          TAG: ${{ needs.version.outputs.tag }}
          REPO: ${{ github.repository }}
        run: |
          # Read metadata
          DESCRIPTION=$(jq -r '.description' plugins/${PLUGIN}/version.json)
          PUBLISHER=$(jq -r '.publisher' plugins/${PLUGIN}/version.json)

          # Generate plugin page in its subdirectory
          mkdir -p _site/${PLUGIN}
          sed -e "s|{{VERSION}}|$VERSION|g" \
              -e "s|{{TAG}}|$TAG|g" \
              -e "s|{{REPO}}|$REPO|g" \
              -e "s|{{NAME}}|$PLUGIN_NAME|g" \
              -e "s|{{DESCRIPTION}}|$DESCRIPTION|g" \
              -e "s|{{PUBLISHER}}|$PUBLISHER|g" \
              plugins/${PLUGIN}/docs/index.html > _site/${PLUGIN}/index.html

          # Copy plugin-specific assets
          cp -r plugins/${PLUGIN}/docs/assets _site/${PLUGIN}/ 2>/dev/null || true

      - name: Generate Root Index
        env:
          REPO: ${{ github.repository }}
        run: |
          mkdir -p _site/assets

          # Copy root page assets
          cp docs/assets/style.css _site/assets/

          # Generate plugin cards from all version.json files and fill root template
          python3 << 'PYEOF'
          import json, glob, os

          plugins = []
          for vj in sorted(glob.glob('plugins/*/version.json')):
              with open(vj) as f:
                  data = json.load(f)
              plugin_dir = os.path.basename(os.path.dirname(vj))
              data['dir'] = plugin_dir
              # Only link to plugins that have a landing page
              has_page = os.path.isfile(f'plugins/{plugin_dir}/docs/index.html')
              data['has_page'] = has_page
              plugins.append(data)

          cards = '\n'.join([
              f'                <a href="{p["dir"]}/" class="plugin-card">'
              f'\n                    <h2>{p["name"]}</h2>'
              f'\n                    <p class="description">{p["description"]}</p>'
              f'\n                    <span class="version">v{p["version"]}</span>'
              f'\n                </a>'
              if p['has_page'] else
              f'                <div class="plugin-card">'
              f'\n                    <h2>{p["name"]}</h2>'
              f'\n                    <p class="description">{p["description"]}</p>'
              f'\n                    <span class="version">v{p["version"]}</span>'
              f'\n                </div>'
              for p in plugins
          ])

          repo = os.environ['REPO']
          with open('docs/index-template.html') as f:
              template = f.read()

          html = template.replace('{{PLUGIN_CARDS}}', cards).replace('{{REPO}}', repo)

          os.makedirs('_site', exist_ok=True)
          with open('_site/index.html', 'w') as f:
              f.write(html)
          PYEOF

      - name: Deploy to gh-pages
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ github.token }}
          publish_dir: ./_site
          keep_files: true
