# Oscillator & Waveform Generation: Comprehensive Research Report

## Overview

This report covers oscillator design, anti-aliasing techniques, wavetable synthesis, FM/PM synthesis, and advanced modulation methods for digital audio signal processing (DSP), compiled for use in the Krate Audio library development.

---

## 1. The Aliasing Problem

When generating classic waveforms (sawtooth, square, triangle, pulse) digitally, a fundamental problem arises: these waveforms contain theoretically infinite harmonics, but digital sampling imposes a hard limit at the Nyquist frequency (half the sample rate). Any frequency content above Nyquist "folds back" into the audible range as inharmonic, metallic artifacts called aliasing.

At 44.1 kHz sample rate, any fundamental above ~1.3 kHz will alias, folding high harmonics back into the audible range as harsh artifacts. The same problem affects square waves, pulse width modulation, and hard sync—anywhere you have instantaneous jumps in amplitude.

### Why Naive Waveforms Fail

A "naive" sawtooth generated by simple phase accumulation:
```
output = phase * 2.0 - 1.0  // Maps [0,1] to [-1,1]
phase += frequency / sampleRate
if (phase >= 1.0) phase -= 1.0
```

This creates discontinuities that contain infinite frequency content, causing severe aliasing especially at higher pitches.

---

## 2. Anti-Aliasing Techniques

### 2.1 PolyBLEP (Polynomial Band-Limited Step)

PolyBLEP is a lightweight technique that corrects discontinuities using polynomial functions computed on-the-fly, requiring no lookup tables.

**Key Concepts:**
- Corrects 2 samples per discontinuity (extendable to 3-4 for better quality)
- Variable `t` = phase/2π (normalized 0-1), `dt` = frequency/sampleRate
- Generate naive waveform, then subtract poly_blep(t) at discontinuities

**Core Algorithm:**
```typescript
function polyBlep(t: number, dt: number): number {
  // t: normalized phase [0, 1]
  // dt: phase increment per sample
  if (t < dt) {
    // Beginning of period
    const x = t / dt
    return x + x - x * x - 1.0
  } else if (t > 1.0 - dt) {
    // End of period
    const x = (t - 1.0) / dt
    return x * x + x + x + 1.0
  }
  return 0.0
}
```

**Implementation for Sawtooth:**
```typescript
function sawtoothPolyBlep(phase: number, dt: number): number {
  // Naive sawtooth: ramps from -1 to +1
  let saw = 2.0 * phase - 1.0
  // Apply correction at discontinuity (phase wrap)
  saw -= polyBlep(phase, dt)
  return saw
}
```

**Implementation for Square/Pulse:**
```typescript
function squarePolyBlep(phase: number, dt: number, pulseWidth: number = 0.5): number {
  let square = phase < pulseWidth ? 1.0 : -1.0
  // Correct both discontinuities
  square += polyBlep(phase, dt)  // Rising edge
  square -= polyBlep((phase + 1.0 - pulseWidth) % 1.0, dt)  // Falling edge
  return square
}
```

**Triangle Wave:**
Use BLAMP (integrated BLEP) for derivative discontinuities, or integrate an antialiased square wave.

**Quality Assessment:**
- Good balance of simplicity and quality
- Moderate aliasing reduction, slightly duller than minBLEP
- **PolyBLEP + 2x oversampling = excellent results**
- At very high frequencies: crossfade to brute-force Fourier series when fundamental approaches Nyquist
- Precision: 8-10 bits sufficient for t calculation; each bit adds ~1 octave of virtual oversampling
- Handles modulation well (unlike wavetables)

**Sources:** KVR Audio forums, Martin Finke blog, DAFx papers, Välimäki & Huovilainen papers

---

### 2.2 BLIT (Band-Limited Impulse Train)

BLIT creates streams of lowpass filtered impulses (sinc functions) that are integrated to obtain the desired bandlimited waveform.

**Key Concepts:**
- The impulse response of an ideal lowpass filter is band-limited by nature
- Unipolar BLIT → sawtooth (via integration)
- Bipolar BLIT → square wave (via integration)
- Doubly integrated bipolar BLIT → triangle

**DSF (Discrete Summation Formula):**
```typescript
function blit(phase: number, sampleRate: number, frequency: number): number {
  const P = sampleRate / frequency  // Samples per period
  const M = 2 * Math.floor(P * 0.5) + 1  // Number of harmonics
  const x = phase  // Normalized phase [0, 1]

  const denom = M * Math.sin(Math.PI * x)
  if (Math.abs(denom) < 1e-10) {
    return 1.0  // Avoid division by zero at phase = 0
  }
  return (M / P) * Math.sin(Math.PI * x * M) / denom
}
```

**Characteristics:**
- Features ringing on band edges
- Aliasing reduced but not eliminated
- Computationally expensive in real-time, often stored in tables with interpolation
- "More or less no aliasing at any frequency" - superior to BLEP in many cases

**LP-BLIT Variant:**
Uses Hammerich pulse instead of sinc for adjustable lowpass characteristic with cutoff ωc and stopband slope α.

**IIR-based BLIT:**
Better stopband rejection than FIR-based approaches.

**Implementation Note:**
Linear-phase BLEPs recommended. If oversampling for filters anyway, run BLEP oscillator at higher rate directly.

**Sources:** Stilson & Smith 1996, DAFx papers, Stanford CCRMA, music-dsp archives

---

### 2.3 minBLEP (Minimum-Phase Band-Limited Step)

minBLEP is a windowed sinc (BLIT) that has been integrated (BLEP) and converted to minimum-phase, placing the energy hump at the beginning of the window instead of the middle.

**Key Advantages:**
- No lookahead required (unlike linear-phase)
- Better quality than PolyBLEP
- Requires precomputed FFT tables

**Implementation Approach:**
1. Precompute large polyphase FIR table via FFT
2. At each discontinuity, mix the appropriate BLEP branch into output buffer
3. Scale by discontinuity height

**Algorithm:**
```typescript
// For each sample:
// 1. Increment phase
// 2. While phase > 1:
//    a. Solve exact crossing time within sample
//    b. Pick branch from polyphase BLEP table
//    c. Mix/scale into output buffer
//    d. Subtract 1 from phase
// 3. Add trivial value with latency offset
```

**Sub-sample Accuracy:**
Use oversampled pre-calculated BLEP to prevent phase noise.

**Characteristics:**
- Works gracefully above Nyquist
- Extends to piecewise polynomial waves
- Can be used for hard sync

**Criticism:**
Some argue linear-phase BLEPs are more efficient; minBLEPs have been called "a fail" due to latency concerns in certain applications.

**Sources:** Eli Brandt "Hard Sync Without Aliasing", KVR Audio forums, VCV Rack implementations

---

### 2.4 DPW (Differentiated Polynomial Waveforms)

DPW (Välimäki et al. 2010) extends differentiated parabolic wave to higher polynomial orders.

**Core Concept:**
Generate polynomial waveform, differentiate one or more times to obtain improved waveforms.

**DPW-2 (Second-Order):**
```typescript
function dpw2Sawtooth(phase: number, lastPhase: number, dt: number): number {
  // Square the naive saw
  const x0 = phase * 2.0 - 1.0  // Current naive saw
  const x1 = lastPhase * 2.0 - 1.0  // Previous naive saw

  // Parabola (squared saw)
  const p0 = x0 * x0
  const p1 = x1 * x1

  // Differentiate (difference and scale)
  return (p0 - p1) / (4.0 * dt)
}
```

**Quality Thresholds (at 44.1kHz):**
- DPW-2: Audible aliasing above 600Hz
- DPW-4: Alias-free up to ~4.6kHz
- DPW2X (DPW-2 with 2x oversampling): Recommended approach

**Aliasing Rolloff:**
6 dB/octave per differentiation order.

**Practical Issues:**
- Pitch modulation causes crackles (difficult to eliminate)
- Works best for static pitch oscillators
- Quantization noise affects each differentiation step

**Equivalence:**
DPW is equivalent to AA-FIR methods (antiderivative antialiasing).

**Sources:** Välimäki, Nam, Smith, Abel IEEE papers, music-dsp discussions

---

### 2.5 Comparison Summary

| Method | Complexity | Tables | Quality | Modulation | Best Use |
|--------|-----------|--------|---------|------------|----------|
| PolyBLEP | Simple | None | Good | Excellent | Real-time, modulated |
| BLIT | Medium | Optional | Very Good | Good | Static pitch |
| minBLEP | Complex | Required | Excellent | Excellent | Hard sync, high quality |
| DPW | Simple | None | Variable | Poor | Static oscillators |

**Recommendations:**
- For general-purpose virtual analog: PolyBLEP + 2x oversampling
- For hard sync: minBLEP
- For maximum quality: minBLEP or BLIT with tables
- Avoid: Oversampling alone (need 1024x for good results)

---

## 3. Wavetable Synthesis

### 3.1 Mipmapping Strategy

Multiple bandlimited versions at different frequency ranges prevent aliasing when playing at different pitches.

**Generation Methods:**
1. **FFT Method:** FFT → zero upper bins → IFFT → downsample
2. **Additive Synthesis:** Directly synthesize pushing harmonics to Nyquist limit (best quality)

**Table Sizes:**
- 2048 samples = "sweet spot" (covers 20Hz at 44.1kHz with ~20kHz Nyquist)
- Sine table: 512 samples = 97dB SNR (16-bit equivalent), +12dB per doubling

**Mipmap Spacing:**
- Every semitone = more than enough
- Every octave = not quite enough
- Recommended: Every octave with interpolation

**Transition Methods:**
- Switch at zero crossings (good results)
- Crossfade between mipmaps (smoother but more CPU)

### 3.2 Phase Accumulator Implementation

```typescript
interface WavetableOscillator {
  wavetable: Float32Array[]  // Array of mipmap levels
  tableSize: number
  phase: number

  getSample(frequency: number, sampleRate: number): number
}

function wavetableSample(
  osc: WavetableOscillator,
  frequency: number,
  sampleRate: number
): number {
  // Select mipmap level based on frequency
  const mipmapLevel = selectMipmapLevel(frequency, sampleRate, osc.tableSize)
  const table = osc.wavetable[mipmapLevel]

  // Phase increment
  const phaseIncrement = frequency * osc.tableSize / sampleRate

  // Fractional indexing with linear interpolation
  const indexFloat = osc.phase * osc.tableSize
  const index0 = Math.floor(indexFloat) % osc.tableSize
  const index1 = (index0 + 1) % osc.tableSize
  const frac = indexFloat - Math.floor(indexFloat)

  const sample = table[index0] * (1.0 - frac) + table[index1] * frac

  // Advance phase
  osc.phase += phaseIncrement / osc.tableSize
  if (osc.phase >= 1.0) osc.phase -= 1.0

  return sample
}
```

### 3.3 Interpolation Quality

- **Linear:** Sufficient for oversampled tables
- **Cubic/Hermite:** For non-oversampled tables
- **4-6 point spline:** For oversampled signals needing highest quality
- **Band-limited interpolation:** Build lowpass into interpolator (see Stanford CCRMA resample docs)

**Sources:** KVR Audio forums, EarLevel Engineering, music-dsp archives

---

## 4. FM/PM Synthesis

### 4.1 Fundamentals

Developed by John Chowning at Stanford (1967-1973), licensed to Yamaha 1973.

**Key Insight:**
Yamaha's implementation is actually **Phase Modulation (PM)**, mathematically equivalent to FM but with better pitch stability.

- Carrier frequency never changes, only phase
- Linear frequency mapping (PM) vs exponential (true FM)
- Patent expired 1995

### 4.2 Implementation

**Operators:** Mini-synthesizers with oscillator + envelope generator, typically sine waves.

**Algorithms:** Configurations of operators in modulator/carrier relationships.
- DX7: 32 algorithms, 6 operators
- Modern (FM-X): 8 operators with multi-spectral waveforms

```typescript
interface FMOperator {
  frequency: number
  ratio: number  // Frequency ratio to fundamental
  index: number  // Modulation index (depth)
  phase: number
  envelope: EnvelopeGenerator
}

function fmSynth(
  carrier: FMOperator,
  modulator: FMOperator,
  sampleRate: number
): number {
  // Modulator output
  const modPhaseInc = (modulator.frequency * modulator.ratio) / sampleRate
  modulator.phase += modPhaseInc
  if (modulator.phase >= 1.0) modulator.phase -= 1.0

  const modOutput = Math.sin(2 * Math.PI * modulator.phase)
    * modulator.index
    * modulator.envelope.getValue()

  // Carrier with phase modulation
  const carPhaseInc = carrier.frequency / sampleRate
  carrier.phase += carPhaseInc
  if (carrier.phase >= 1.0) carrier.phase -= 1.0

  // Apply modulation to carrier phase
  const modulatedPhase = carrier.phase + modOutput

  return Math.sin(2 * Math.PI * modulatedPhase) * carrier.envelope.getValue()
}
```

### 4.3 Key Concepts

**Modulation Index:** Controls spectral complexity (depth of modulation).

**Feedback:** Yamaha innovation - operator output routed back to input for additional sidebands.

**Carrier:Modulator Ratios:**
- Integer ratios = harmonic spectra
- Non-integer ratios = inharmonic/bell-like spectra

**Sound Design Applications:**
- Electric pianos, bells, mallets, brass
- Metallic sounds, complex attacks
- Envelope per operator: Carriers control amplitude, modulators control timbral evolution

**Sources:** Chowning papers, Yamaha documentation, Perfect Circuit, Roland articles

---

## 5. Oscillator Sync

### 5.1 Hard Sync

When the master oscillator completes a cycle, it resets the slave oscillator's phase regardless of the slave's position.

**Implementation:**
```typescript
interface SyncOscillator {
  masterPhase: number
  slavePhase: number
  masterFreq: number
  slaveFreq: number
}

function hardSyncSample(osc: SyncOscillator, sampleRate: number): number {
  const masterInc = osc.masterFreq / sampleRate
  const slaveInc = osc.slaveFreq / sampleRate

  osc.masterPhase += masterInc
  osc.slavePhase += slaveInc

  // Check for master reset
  if (osc.masterPhase >= 1.0) {
    osc.masterPhase -= 1.0
    // Reset slave to master's fractional position (important!)
    osc.slavePhase = osc.masterPhase * (slaveInc / masterInc)
  }

  // Output from slave oscillator
  return Math.sin(2 * Math.PI * osc.slavePhase)
}
```

**Bandlimited Hard Sync:**
Place BLEP at the reset point. Tricky when phase wrap and hard sync occur at same sample.

**Key Implementation Detail:**
Reset slave phase to master's phase (not zero) to avoid glitches when both oscillators have identical settings.

### 5.2 Soft Sync Variants

**Reversing Soft Sync:**
Instead of resetting to zero, the wave is inverted (direction reversed). More associated with triangle-core oscillators. Generates less aliasing due to preserved waveform continuity.

**Threshold/Weak Sync:**
Hard sync disabled when slave frequency crosses user-defined threshold or extends too far from master frequency.

**Phase Advance Sync:**
Phase of slave is advanced by fixed amount each time master crosses threshold (gentler entrainment).

**Sources:** Wikipedia, Noise Engineering, Perfect Circuit, KVR Audio forums

---

## 6. Sub-Oscillators

### 6.1 Analog Heritage

Sub-oscillators are traditionally derived from the main oscillator using flip-flop frequency dividers, not separate oscillators.

**Why Square Wave:**
The divide-by-two process itself produces a square wave output. Additional circuitry would be needed for other waveforms.

**Implementation:**
```typescript
interface SubOscillator {
  mainPhase: number
  subState: boolean  // Flip-flop state
  lastMainPhase: number
}

function subOscSample(osc: SubOscillator, mainSample: number): number {
  // Detect main oscillator zero crossing (rising edge)
  if (osc.mainPhase < osc.lastMainPhase) {
    osc.subState = !osc.subState  // Toggle on main osc reset
  }
  osc.lastMainPhase = osc.mainPhase

  return osc.subState ? 1.0 : -1.0  // Square wave one octave down
}
```

**Two-Octave Sub:**
Chain two flip-flops (divide by 4 instead of 2).

### 6.2 Digital Implementation

With minBLEP, a suboscillator is computationally cheap: just two multiplies and an add during phase reset.

**Waveform Options:**
- Digital synths can offer sine, triangle, or other sub-oscillator waveforms
- Sine wave subs add bass without coloring harmonics

**Sources:** Electric Druid, KVR Audio, Gearspace, mod wiggler

---

## 7. Supersaw / Unison

### 7.1 Roland JP-8000/8080 Supersaw

Analyzed by Adam Szabo's bachelor thesis.

**Architecture:**
- 7 sawtooth oscillators: 1 center + 6 detuned (3 pairs)
- Detune curve: Non-linear (small spread at midpoint, rapid increase at high values)
- Detune amounts: Not evenly spaced

**Key Discovery (JE-8086 emulator):**
The "secret" is 7 naive saws at 88.2kHz sample rate → highpass filter. No phase tricks or chorus required. The high sample rate prevents aliasing.

**Highpass Filter:**
Q = √2, cutoff at 2.5 × fundamental. Removes harsh noise below fundamental.

```typescript
interface SupersawOscillator {
  centerPhase: number
  detunePhases: number[]  // 6 detuned oscillators
  detuneAmounts: number[]  // Cents detune for each
  mixAmount: number  // Balance center vs detuned
}

function supersawDetune(detuneParam: number): number[] {
  // Non-linear detune curve (approximation)
  // Returns 6 detune amounts in cents
  const spread = detuneParam * detuneParam * 50  // Quadratic curve
  return [
    -spread * 0.28,
    -spread * 0.80,
    -spread * 1.00,
    spread * 0.28,
    spread * 0.80,
    spread * 1.00
  ]
}
```

### 7.2 General Unison

**Oscillator Unison:** Per-oscillator feature, minimal polyphony impact.

**Global Unison:** Full voice cards, reduces polyphony (e.g., Prophet 5 → monophonic with 5-voice unison).

**Detune Strategies:**
- Exponential spread curves
- Per-oscillator fast vibrato (20-35Hz triangle LFOs)
- Stereo spread: Pan different voices across stereo field

**Sources:** Adam Szabo thesis, JP6K plugin, KVR Audio, Synthanatomy JE-8086 article

---

## 8. LFO (Low Frequency Oscillator)

### 8.1 Fundamentals

LFOs operate below audible range (typically 0.1 Hz to 20 Hz) and modulate other parameters rather than producing sound directly.

**Common Waveforms:**
- Sine: Smooth, subtle modulation
- Triangle: Slightly more pronounced than sine
- Square: Abrupt on/off modulation
- Sawtooth: Ramp effects
- Sample & Hold: Random values at regular intervals

### 8.2 Implementation

```typescript
interface LFO {
  phase: number
  rate: number  // Hz or tempo-synced division
  waveform: 'sine' | 'triangle' | 'square' | 'saw' | 'sampleHold'
  depth: number  // Modulation amount
  isTempoSynced: boolean
}

function lfoSample(lfo: LFO, sampleRate: number): number {
  // Advance phase
  const phaseInc = lfo.rate / sampleRate
  lfo.phase += phaseInc
  if (lfo.phase >= 1.0) lfo.phase -= 1.0

  // Generate waveform
  let value: number
  switch (lfo.waveform) {
    case 'sine':
      value = Math.sin(2 * Math.PI * lfo.phase)
      break
    case 'triangle':
      value = 4 * Math.abs(lfo.phase - 0.5) - 1
      break
    case 'square':
      value = lfo.phase < 0.5 ? 1 : -1
      break
    case 'saw':
      value = 2 * lfo.phase - 1
      break
    case 'sampleHold':
      // Hold random value until phase resets
      // Requires additional state tracking
      break
  }

  return value * lfo.depth
}
```

### 8.3 Tempo Sync

```typescript
function calculateTempoSyncedRate(
  bpm: number,
  division: string  // e.g., "1/4", "1/8", "1/16"
): number {
  const beatsPerSecond = bpm / 60

  const divisionScalers: Record<string, number> = {
    '4/1': 0.25,   // 4 bars
    '2/1': 0.5,    // 2 bars
    '1/1': 1.0,    // 1 bar
    '1/2': 2.0,    // Half note
    '1/4': 4.0,    // Quarter note
    '1/8': 8.0,    // Eighth note
    '1/16': 16.0,  // Sixteenth note
    '1/32': 32.0,  // Thirty-second note
  }

  return beatsPerSecond * (divisionScalers[division] / 4)
}

// For sample-accurate sync to host position:
function syncLfoToHost(
  lfo: LFO,
  ppqPosition: number,  // Current position in quarter notes
  division: string
): void {
  const scaler = getDivisionScaler(division)
  const phase = ppqPosition * scaler
  lfo.phase = phase - Math.floor(phase)  // Fractional part only
}
```

### 8.4 Key Features

**Retrigger/Reset:**
- Monophonic: Single LFO shared by all voices
- Polyphonic: Separate LFO per voice, reset on note-on
- Free-running: No reset, continuous cycling

**Phase Offset:**
Allow starting LFO at arbitrary point in cycle.

**Fade-in/Delay:**
Gradually introduce LFO modulation after note onset.

**Audio-rate Modulation:**
LFOs above 20Hz create FM-like sideband harmonics.

**Sources:** Wikipedia, Native Instruments, LANDR, KVR Audio forums

---

## 9. Noise Generation

### 9.1 White Noise

Equal energy at all frequencies, uncorrelated samples.

```typescript
function whiteNoise(): number {
  return Math.random() * 2 - 1  // Uniform distribution [-1, 1]
}
```

**Better Quality:**
Use xorshift or Mersenne Twister for better statistical properties.

### 9.2 Pink Noise (1/f)

Equal energy per octave, -3dB/octave rolloff.

**Voss-McCartney Algorithm:**
Sum multiple white noise sources at octave-spaced update rates.

**Pinking Filter (Paul Kellet):**
```typescript
// Paul Kellet's "economy" pink noise filter
interface PinkNoiseState {
  b0: number
  b1: number
  b2: number
}

function pinkNoise(state: PinkNoiseState): number {
  const white = Math.random() * 2 - 1

  state.b0 = 0.99765 * state.b0 + white * 0.0990460
  state.b1 = 0.96300 * state.b1 + white * 0.2965164
  state.b2 = 0.57000 * state.b2 + white * 1.0526913

  return state.b0 + state.b1 + state.b2 + white * 0.1848
}
```

### 9.3 Brown Noise (1/f²)

Brownian motion, integral of white noise, -6dB/octave.

```typescript
function brownNoise(lastValue: number): number {
  const white = Math.random() * 2 - 1
  let brown = lastValue + white * 0.02
  brown = Math.max(-1, Math.min(1, brown))  // Clamp
  return brown
}
```

### 9.4 Other Colors

- **Blue noise (f):** Derivative of white, +6dB/octave
- **Violet/Purple (f²):** +12dB/octave
- **Custom:** 1/f^α where α ∈ [-2, 2]

**Sources:** firstpr.com.au DSP pink noise, music-dsp archives, Electric Druid

---

## 10. Additive Synthesis

### 10.1 Fundamentals

Sum of sinusoids at different frequencies, amplitudes, and phases.

```typescript
interface AdditivePartial {
  frequency: number  // Can be harmonic (n * fundamental) or inharmonic
  amplitude: number
  phase: number
}

function additiveSynth(
  partials: AdditivePartial[],
  fundamental: number,
  time: number
): number {
  let output = 0
  for (const partial of partials) {
    const freq = partial.frequency * fundamental
    output += partial.amplitude * Math.sin(2 * Math.PI * freq * time + partial.phase)
  }
  return output
}
```

### 10.2 Harmonic vs Inharmonic

- **Harmonic:** Integer multiples of fundamental (most pitched sounds)
- **Inharmonic:** Non-integer ratios (bells, metallic sounds)

### 10.3 Practical Challenges

- **Parameter complexity:** Large number of oscillators tedious to control
- **Transients:** Difficult - require many rapidly varying overtones
- **Organ-like quality:** Common result without careful envelope/modulation per partial

**Solutions:**
- Macro controls mapping to multiple partials
- Morphing between presets
- Analysis/resynthesis tools (SPEAR, LEMUR, LORIS, SMS)

### 10.4 Efficient Methods

- **Inverse FFT:** For evenly-spaced frequencies
- **Group additive:** Group partials into harmonic groups
- Modern systems can manage 500+ sine waves on contemporary hardware

**Sources:** Wikipedia, McGill University, Perfect Circuit, Sound on Sound

---

## 11. Vector Synthesis

### 11.1 Prophet VS (Sequential Circuits 1986)

Chris Meyer concept: 2D interpolation between 4 waveforms arranged at corners of a diamond.

**Vector Joystick:**
Traverse seamlessly between four oscillators. Mix parameter changes dynamically.

**Vector Envelope:**
Multi-breakpoint envelope controlling vector position (can loop, reverse).

### 11.2 Korg Wavestation

**Wave Sequencing:**
List of PCM waves stepped through in order (up to 255 waveforms).

**Per-step Control:**
Volume, pitch, crossfade amount, duration.

**Performance Mode:**
Up to 32 discrete wave sequences (8 patches × 4 oscillators).

### 11.3 Implementation Concept

```typescript
interface VectorOscillator {
  oscillators: [Oscillator, Oscillator, Oscillator, Oscillator]
  vectorX: number  // -1 to 1
  vectorY: number  // -1 to 1
}

function vectorMix(vec: VectorOscillator): number {
  // Convert XY to four corner weights
  const topLeft = (1 - vec.vectorX) * (1 - vec.vectorY) / 4
  const topRight = (1 + vec.vectorX) * (1 - vec.vectorY) / 4
  const bottomLeft = (1 - vec.vectorX) * (1 + vec.vectorY) / 4
  const bottomRight = (1 + vec.vectorX) * (1 + vec.vectorY) / 4

  return vec.oscillators[0].getSample() * topLeft
       + vec.oscillators[1].getSample() * topRight
       + vec.oscillators[2].getSample() * bottomLeft
       + vec.oscillators[3].getSample() * bottomRight
}
```

**Sources:** Perfect Circuit, Learning Modular, Vintage Synth Explorer

---

## 12. Phase Distortion Synthesis

### 12.1 Casio CZ Series (1984)

Developed by Mark Fukuda.

**Core Concept:**
Scan sine wave lookup table at varying speed while keeping frequency constant. This distorts the phase of the phasor reading through the sine table.

**8 Waveforms:**
Saw, square, pulse, double sine, half-sine, resonant saw, resonant triangle, resonant trapezoid.

**DCW (Digitally Controlled Wave):**
Controls magnitude of phase distortion (0 = sine, max = selected shape). Acts like VCF cutoff.

### 12.2 Implementation

```typescript
function phaseDistortion(
  phase: number,        // Linear phase [0, 1]
  distortionAmount: number,  // 0 = sine, 1 = full distortion
  waveformType: string
): number {
  // Transform linear phase to distorted phase
  let distortedPhase: number

  switch (waveformType) {
    case 'saw':
      // Faster at start, slower at end
      distortedPhase = acceleratedPhase(phase, distortionAmount)
      break
    case 'resonant':
      // Windowed sync technique
      distortedPhase = resonantPhase(phase, distortionAmount)
      break
    // ... other waveforms
  }

  return Math.sin(2 * Math.PI * distortedPhase)
}

function acceleratedPhase(phase: number, amount: number): number {
  // Simple example: accelerate through first half, decelerate through second
  if (phase < 0.5) {
    const rate = 1 + amount
    return phase * rate * 2
  } else {
    return 1 - (1 - phase) * 2
  }
}
```

### 12.3 vs FM/PM

- PD: Modulators at same frequency as carrier, limited frequency range
- PD: More linear spectra (easier to produce traditional subtractive sounds)
- FM: Bessel function-derived spectra
- PD: Modulator waveshape can be modified

**Sources:** Wikipedia, Electric Druid, Pro Audio Files, MusicRadar, DAFx papers

---

## 13. Waveform Morphing

### 13.1 Methods

**Simple Crossfade:**
Works if waveforms are phase-aligned. Requires equal-power crossfade for non-phase-locked sources.

```typescript
function crossfade(a: number, b: number, mix: number): number {
  // Linear crossfade
  return a * (1 - mix) + b * mix
}

function equalPowerCrossfade(a: number, b: number, mix: number): number {
  // Equal power (constant loudness)
  return a * Math.cos(mix * Math.PI / 2) + b * Math.sin(mix * Math.PI / 2)
}
```

**Additive/Spectral Morphing:**
Interpolate gains of individual partials from one wave to another.

```typescript
function spectralMorph(
  partialsA: number[],
  partialsB: number[],
  mix: number
): number[] {
  return partialsA.map((a, i) =>
    a * (1 - mix) + partialsB[i] * mix
  )
}
```

**Control Point Morphing:**
Construct waves from key points and curves, interpolate between corresponding key points.

### 13.2 Wavetable Interpolation Types

- **1D:** String of waves (Serum, Vital, Iridium)
- **2D:** XY grid (Synthesis Technology modules, 4MS SWN)
- **3D:** XYZ cube (Plaits)

**Sources:** cycling74 forums, mod wiggler, KVR Audio, Stanford CCRMA

---

## 14. Advanced Techniques

### 14.1 Feedback FM

Operator output routed back to input (self-modulation or cross-modulation).

**Characteristics:**
- Creates additional sidebands without extra operators
- Chaotic behavior: Too much feedback → instability, noise
- Related to iterated nonlinear map dynamics (logistic map)

### 14.2 Waveshaping

Non-linear transfer function applied to input signal.

```typescript
// Soft clipping (tanh)
function tanhWaveshaper(input: number, drive: number): number {
  return Math.tanh(input * drive)
}

// Chebyshev polynomial waveshaping
function chebyshev(input: number, order: number): number {
  // Generates nth harmonic from sine input
  return Math.cos(order * Math.acos(input))
}
```

**Note:** Avoid hard clipping on audio-rate signals as it reintroduces aliasing.

### 14.3 Through-Zero FM (TZFM)

Linear FM that crosses through zero frequency, producing unique timbres impossible with standard FM.

### 14.4 Chaotic Synthesis

Complex oscillator with two oscillators cross-modulating frequency/amplitude.

- Mild settings: Unique harmonically rich timbres
- Increased modulation: Noise bursts, pulsing rhythms
- Strange attractors: Underlying order within chaos

**Sources:** KVR Audio, mod wiggler, academic papers on nonlinear dynamics

---

## 15. Recommendations for Krate Audio

### Anti-Aliasing Strategy

1. **Primary:** PolyBLEP with optional 2x oversampling for quality-critical applications
2. **Hard Sync:** minBLEP for proper bandlimited sync
3. **High frequencies:** Crossfade to limited-harmonic fallback near Nyquist

### Oscillator Architecture

```typescript
interface KrateOscillator {
  // Core
  phase: number
  frequency: number
  waveform: WaveformType

  // Anti-aliasing
  antiAliasMethod: 'polyblep' | 'minblep' | 'none'
  oversampleFactor: 1 | 2 | 4

  // Modulation
  phaseModInput: number
  frequencyModInput: number

  // Sync
  syncEnabled: boolean
  syncInput: number

  // Sub-oscillator
  subEnabled: boolean
  subOctave: 1 | 2
  subWaveform: 'square' | 'sine' | 'triangle'
  subMix: number
}
```

### Feature Priority

**Core Oscillators:**
1. **Phase 1:** Basic oscillators with PolyBLEP (saw, square, pulse, triangle)
2. **Phase 2:** Wavetable oscillator with mipmap support
3. **Phase 3:** FM/PM synthesis module
4. **Phase 4:** Hard sync with minBLEP
5. **Phase 5:** Advanced features (vector, morphing)

**Sound Design / Special FX Oscillators:**
6. **Phase 6:** Chaos attractors (Lorenz, Rössler, Chua)
7. **Phase 7:** Particle/Swarm oscillators
8. **Phase 8:** Rungler/Shift register oscillators
9. **Phase 9:** Granular oscillator
10. **Phase 10:** Formant oscillator (FOF synthesis)

---

## 16. Novel Oscillator Techniques (Sound Design & Special FX)

Creative oscillator approaches beyond traditional synthesis, targeting experimental sound design.

### 16.1 Chaos Attractor Oscillators

Use mathematical chaotic systems as waveform generators rather than periodic functions.

**Lorenz Oscillator:**
```cpp
// State variables (x, y, z) trace a butterfly-shaped attractor
float sigma = 10.0f, rho = 28.0f, beta = 8.0f/3.0f;
float dt = frequency / sampleRate;

x += sigma * (y - x) * dt;
y += (x * (rho - z) - y) * dt;
z += (x * y - beta * z) * dt;

output = x * 0.05f;  // Scale to audio range
```

**Characteristics:**
- Never exactly repeats - organic, living quality
- Pitch loosely controllable via `dt` scaling
- Can transition between periodic and chaotic regimes
- **Rössler attractor:** Smoother, less harsh chaos
- **Chua circuit:** Electronic chaos, analog character
- **Duffing oscillator:** Driven nonlinear spring, controllable chaos threshold

**Sound:** Breathy, evolving textures; pitched noise; organic drones; alien atmospheres

---

### 16.2 Rungler / Shift Register Oscillators

Inspired by Rob Hordijk's Benjolin and Buchla's Source of Uncertainty.

**Concept:**
Two oscillators with a shift register creating pseudo-random CV that modulates both oscillators' frequencies, creating complex feedback loops.

```cpp
struct Rungler {
    uint8_t shiftRegister = 0;  // 8-bit shift register
    float osc1Phase, osc2Phase;
    float osc1Freq, osc2Freq;

    float process() {
        // Osc1 clocks the shift register
        if (osc1Phase wrapped) {
            bool newBit = (osc2Phase > 0.5f);  // Sample osc2
            shiftRegister = (shiftRegister << 1) | newBit;
        }

        // Shift register modulates osc2 frequency
        float runglerCV = shiftRegister / 255.0f;
        osc2Freq = baseFreq * (1.0f + runglerCV * depth);

        return osc1Sample + osc2Sample;
    }
};
```

**Sound:** Stepped random sequences, pitched chaos, self-generating patterns, analog computer vibes

---

### 16.3 Particle/Swarm Oscillators

Many tiny oscillators ("particles") with individual behaviors that emerge into complex timbres.

**Particle Cloud:**
```cpp
struct ParticleOscillator {
    static constexpr int kNumParticles = 64;

    struct Particle {
        float phase;
        float frequency;    // Drifts around center
        float amplitude;    // Fades in/out
        float lifetime;
    };
    std::array<Particle, kNumParticles> particles;

    float process(float centerFreq) {
        float output = 0.0f;
        for (auto& p : particles) {
            // Each particle drifts, fades, respawns
            p.phase += p.frequency / sampleRate;
            p.lifetime -= 1.0f / sampleRate;

            if (p.lifetime <= 0) respawn(p, centerFreq);

            output += std::sin(kTwoPi * p.phase) * p.amplitude;
        }
        return output / kNumParticles;
    }
};
```

**Parameters:**
- Particle density (how many active)
- Frequency scatter (how far from center pitch)
- Lifetime (short = granular, long = unison)
- Spawn pattern (regular, random, burst)

**Sound:** Shimmering textures, granular clouds, evolving pads, spectral smearing

---

### 16.4 Cellular Automata Oscillators

Use 1D cellular automata (like Rule 110, Rule 30) to generate waveforms.

```cpp
struct CellularAutomataOsc {
    std::array<uint8_t, 256> cells;  // Current generation
    uint8_t rule = 110;  // Wolfram rule number
    size_t readPosition = 0;

    float process() {
        // Read current cell as sample
        float sample = (cells[readPosition] ? 1.0f : -1.0f);
        readPosition = (readPosition + 1) % cells.size();

        // Evolve to next generation when we've read all cells
        if (readPosition == 0) evolve();

        return sample;
    }

    void evolve() {
        std::array<uint8_t, 256> next;
        for (size_t i = 0; i < cells.size(); ++i) {
            uint8_t neighborhood =
                (cells[(i-1) % 256] << 2) |
                (cells[i] << 1) |
                cells[(i+1) % 256];
            next[i] = (rule >> neighborhood) & 1;
        }
        cells = next;
    }
};
```

**Rules to explore:**
- **Rule 30:** Chaotic, noise-like
- **Rule 110:** Complex patterns, Turing-complete
- **Rule 90:** Sierpinski triangle, more structured

**Sound:** Digital textures, evolving patterns, bit-based timbres, generative sequences

---

### 16.5 Physical Modeling Micro-Oscillators

Beyond Karplus-Strong - unusual physical systems as oscillators.

**Double Pendulum (Chaotic):**
```cpp
// Two coupled pendulums exhibit chaotic motion
struct DoublePendulum {
    float theta1, theta2;      // Angles
    float omega1, omega2;      // Angular velocities
    float m1, m2, L1, L2;      // Masses and lengths

    float process() {
        // Equations of motion (simplified)
        float g = 9.81f;
        // ... complex coupled differential equations ...

        // Output is tip position or angular velocity
        return omega1 * 0.1f;
    }
};
```

**Bouncing Ball:**
```cpp
// Ball bouncing with damping - creates rhythmic impulses
struct BouncingBall {
    float height, velocity;
    float gravity = 9.81f;
    float damping = 0.7f;

    float process() {
        velocity -= gravity * dt;
        height += velocity * dt;

        if (height <= 0) {
            height = 0;
            velocity = -velocity * damping;
            return 1.0f;  // Impact impulse
        }
        return 0.0f;
    }
};
```

**Sound:** Organic rhythms, accelerating patterns, natural chaos

---

### 16.6 Formant Oscillators

Direct synthesis of vowel-like spectra without filters.

**FOF (Fonction d'Onde Formantique):**
IRCAM's technique - damped sinusoids creating formant peaks.

```cpp
struct FormantOscillator {
    struct Formant {
        float frequency;    // Formant center (e.g., 800 Hz for "a")
        float bandwidth;    // Width of formant
        float amplitude;
    };
    std::array<Formant, 5> formants;  // 5 formants for vowels

    float process(float fundamentalPhase) {
        float output = 0.0f;
        for (const auto& f : formants) {
            // Damped sinusoid at formant frequency
            float decay = std::exp(-kPi * f.bandwidth * time);
            output += decay * std::sin(kTwoPi * f.frequency * time)
                    * f.amplitude;
        }
        // Reset on fundamental period
        if (fundamentalPhase wrapped) resetFormants();
        return output;
    }
};
```

**Vowel presets:**
- A: [800, 1200, 2500, 3500, 4500] Hz
- E: [400, 2000, 2600, 3200, 3700] Hz
- I: [300, 2300, 3000, 3500, 4500] Hz

**Sound:** Voice-like tones, talking synths, choir pads

---

### 16.7 Glitch / Artifact Oscillators

Intentionally create digital errors as musical elements.

**Buffer Glitch Oscillator:**
```cpp
struct GlitchOscillator {
    std::array<float, 2048> buffer;
    size_t writePos = 0, readPos = 0;
    float glitchProbability = 0.01f;

    float process(float input) {
        buffer[writePos] = input;
        writePos = (writePos + 1) % buffer.size();

        // Occasionally corrupt read position
        if (random() < glitchProbability) {
            readPos = random() * buffer.size();  // Jump
            // Or: readPos += random() * 100 - 50;  // Stutter
            // Or: readPos = writePos - random() * 10;  // Micro-repeat
        }

        readPos = (readPos + 1) % buffer.size();
        return buffer[readPos];
    }
};
```

**Bit Error Oscillator:**
```cpp
float process(float phase) {
    float sample = std::sin(kTwoPi * phase);

    // Randomly flip bits in the float representation
    if (random() < errorRate) {
        uint32_t bits = std::bit_cast<uint32_t>(sample);
        bits ^= (1 << (random() * 23));  // Flip random mantissa bit
        sample = std::bit_cast<float>(bits);
        sample = std::clamp(sample, -1.0f, 1.0f);
    }
    return sample;
}
```

**Sound:** Digital destruction, stuttering, data corruption aesthetics

---

### 16.8 Spectral Freeze Oscillator

Capture and loop a single FFT frame indefinitely.

```cpp
struct SpectralFreezeOsc {
    SpectralBuffer frozenSpectrum;
    float phase = 0.0f;
    bool frozen = false;

    void freeze(const SpectralBuffer& currentSpectrum) {
        frozenSpectrum = currentSpectrum;  // Capture magnitudes + phases
        frozen = true;
    }

    float process() {
        if (!frozen) return 0.0f;

        // Resynthesize from frozen spectrum with advancing phase
        float output = 0.0f;
        for (size_t bin = 0; bin < frozenSpectrum.numBins(); ++bin) {
            float freq = binToFrequency(bin);
            float mag = frozenSpectrum.getMagnitude(bin);
            float ph = frozenSpectrum.getPhase(bin);
            output += mag * std::sin(kTwoPi * freq * time + ph);
        }
        return output;
    }
};
```

**Sound:** Frozen moments, spectral drones, timestop effects

---

### 16.9 Feedback Network Oscillators

Complex self-modulating oscillator networks.

**Cross-Coupled FM:**
```cpp
struct CrossCoupledFM {
    float phase1, phase2, phase3;
    float freq1, freq2, freq3;
    float fb12, fb23, fb31;  // Cross-feedback amounts

    float process() {
        // Each oscillator modulates the next in a ring
        float out1 = std::sin(kTwoPi * phase1 + fb31 * out3);
        float out2 = std::sin(kTwoPi * phase2 + fb12 * out1);
        float out3 = std::sin(kTwoPi * phase3 + fb23 * out2);

        phase1 += freq1 / sampleRate;
        phase2 += freq2 / sampleRate;
        phase3 += freq3 / sampleRate;

        return (out1 + out2 + out3) / 3.0f;
    }
};
```

**Sound:** Complex evolving timbres, FM-like but less predictable, rich harmonics

---

### 16.10 Granular Oscillator

Generate waveforms from overlapping micro-grains.

```cpp
struct GranularOscillator {
    std::array<float, 4096> sourceWave;  // Base waveform

    struct Grain {
        float position;     // Where in source
        float playhead;     // Current read position
        float length;       // Grain duration
        float pitch;        // Playback rate
        float pan;
    };
    std::array<Grain, 16> grains;

    float process(float frequency) {
        float output = 0.0f;

        for (auto& g : grains) {
            if (g.playhead < g.length) {
                // Hann window envelope
                float env = 0.5f * (1.0f - std::cos(kTwoPi * g.playhead / g.length));

                // Read from source with interpolation
                float readPos = g.position + g.playhead * g.pitch;
                float sample = interpolate(sourceWave, readPos);

                output += sample * env;
                g.playhead += 1.0f / sampleRate;
            }
        }

        // Spawn new grains at regular intervals (based on frequency)
        maybeSpawnGrain(frequency);

        return output;
    }
};
```

**Parameters:**
- Grain size (1-100ms)
- Grain density (overlap)
- Position scatter (read from different parts of source)
- Pitch scatter (each grain at different pitch)

**Sound:** Textured tones, granular clouds, formant-like effects, spectral smearing

---

### 16.11 Fractal Waveform Oscillator

Self-similar waveforms at multiple scales.

```cpp
struct FractalOscillator {
    int iterations = 5;
    float roughness = 0.5f;  // Amplitude scaling per octave

    float process(float phase) {
        float output = 0.0f;
        float amplitude = 1.0f;
        float freq = 1.0f;

        for (int i = 0; i < iterations; ++i) {
            // Each iteration adds detail at higher frequency
            output += std::sin(kTwoPi * phase * freq) * amplitude;
            freq *= 2.0f;           // Double frequency
            amplitude *= roughness;  // Reduce amplitude
        }

        return output / (1.0f / (1.0f - roughness));  // Normalize
    }
};
```

**Variations:**
- Use different base waveforms per iteration
- Non-integer frequency ratios for inharmonic fractals
- Modulate roughness over time

**Sound:** Rich harmonics, organ-like, additive character with coherent structure

---

### 16.12 Pendulum Wave Oscillator

Based on the pendulum wave phenomenon - multiple oscillators with carefully chosen frequency ratios.

```cpp
struct PendulumWaveOsc {
    static constexpr int kNumPendulums = 15;
    std::array<float, kNumPendulums> phases;
    float baseFreq;

    float process() {
        float output = 0.0f;

        for (int i = 0; i < kNumPendulums; ++i) {
            // Each pendulum has slightly different period
            // Creating beating patterns
            float freq = baseFreq * (kNumPendulums + i) / kNumPendulums;
            phases[i] += freq / sampleRate;
            if (phases[i] >= 1.0f) phases[i] -= 1.0f;

            output += std::sin(kTwoPi * phases[i]);
        }

        return output / kNumPendulums;
    }
};
```

**Sound:** Phase-shifting patterns, evolving interference, mesmerizing beating textures

---

### 16.13 Waveset Oscillator

Treat individual waveform cycles as discrete units that can be manipulated.

```cpp
struct WavesetOscillator {
    std::vector<std::vector<float>> wavesets;  // Stored individual cycles
    size_t currentSet = 0;
    size_t readPos = 0;

    enum Mode { Normal, Reverse, Repeat, Skip, Shuffle };
    Mode mode = Normal;
    int repeatCount = 1;

    float process() {
        auto& current = wavesets[currentSet];
        float sample = current[readPos++];

        if (readPos >= current.size()) {
            readPos = 0;
            advanceToNextWaveset();
        }

        return sample;
    }

    void advanceToNextWaveset() {
        switch (mode) {
            case Normal: currentSet++; break;
            case Reverse: currentSet--; break;
            case Repeat: if (--repeatCount <= 0) { currentSet++; repeatCount = repeatAmount; } break;
            case Skip: currentSet += skipAmount; break;
            case Shuffle: currentSet = random() * wavesets.size(); break;
        }
        currentSet %= wavesets.size();
    }
};
```

**Sound:** Granular-like but cycle-coherent, time-stretching, pitch-shifting artifacts, glitchy loops

---

### 16.14 Implementation Recommendations

**Priority for Sound Design:**

1. **Phase 1:** Chaos attractors (Lorenz, Rössler) - immediate impact, simple to implement
2. **Phase 2:** Particle/Swarm oscillators - rich textures, scalable complexity
3. **Phase 3:** Rungler/shift register - unique analog-computer aesthetic
4. **Phase 4:** Granular oscillator - versatile, industry-proven
5. **Phase 5:** Formant oscillator - voice synthesis, musical utility

**Existing Infrastructure Reuse:**
- Particle oscillators → existing LFO for parameter modulation
- Granular oscillator → existing window functions
- Spectral freeze → existing STFT/SpectralBuffer
- Formant oscillator → existing Biquad for filtering

---

## References

### Papers
- Välimäki, V., & Huovilainen, A. "Antialiasing Oscillators in Subtractive Synthesis" (IEEE)
- Stilson, T., & Smith, J. "Alias-Free Digital Synthesis of Classic Analog Waveforms" (ICMC 1996)
- Brandt, E. "Hard Sync Without Aliasing" (ICMC 2001)
- Szabo, A. "Analysis of the Roland JP-8000 Supersaw" (Bachelor's Thesis)
- Chowning, J. "The Synthesis of Complex Audio Spectra by Means of Frequency Modulation"

### Online Resources
- KVR Audio DSP Forum: https://www.kvraudio.com/forum/
- music-dsp mailing list archives
- Stanford CCRMA: https://ccrma.stanford.edu/
- Electric Druid: https://electricdruid.net/
- EarLevel Engineering: https://www.earlevel.com/

### Code References
- VCV Rack (open source): https://github.com/VCVRack/Rack
- Surge Synthesizer: https://github.com/surge-synthesizer/surge
- Dexed (DX7 emulator): https://github.com/asb2m10/dexed

### Novel Oscillator References
- Lorenz system: https://en.wikipedia.org/wiki/Lorenz_system
- Rob Hordijk Benjolin: https://www.modulargrid.net/e/rob-hordijk-benjolin
- Mutable Instruments Plaits (open source): https://github.com/pichenettes/eurorack
- FOF synthesis: IRCAM "Chant" project, Xavier Rodet papers
- Cellular Automata: Stephen Wolfram "A New Kind of Science"
- Curtis Roads "Microsound" (granular synthesis bible)
- Pendulum wave: Harvard Natural Sciences demonstrations
