# Oscillator & Waveform Generation: Comprehensive Research Report

## Overview

This report covers oscillator design, anti-aliasing techniques, wavetable synthesis, FM/PM synthesis, and advanced modulation methods for digital audio signal processing (DSP), compiled for use in the Krate Audio library development.

---

## 1. The Aliasing Problem

When generating classic waveforms (sawtooth, square, triangle, pulse) digitally, a fundamental problem arises: these waveforms contain theoretically infinite harmonics, but digital sampling imposes a hard limit at the Nyquist frequency (half the sample rate). Any frequency content above Nyquist "folds back" into the audible range as inharmonic, metallic artifacts called aliasing.

At 44.1 kHz sample rate, any fundamental above ~1.3 kHz will alias, folding high harmonics back into the audible range as harsh artifacts. The same problem affects square waves, pulse width modulation, and hard sync—anywhere you have instantaneous jumps in amplitude.

### Why Naive Waveforms Fail

A "naive" sawtooth generated by simple phase accumulation:
```
output = phase * 2.0 - 1.0  // Maps [0,1] to [-1,1]
phase += frequency / sampleRate
if (phase >= 1.0) phase -= 1.0
```

This creates discontinuities that contain infinite frequency content, causing severe aliasing especially at higher pitches.

---

## 2. Anti-Aliasing Techniques

### 2.1 PolyBLEP (Polynomial Band-Limited Step)

PolyBLEP is a lightweight technique that corrects discontinuities using polynomial functions computed on-the-fly, requiring no lookup tables.

**Key Concepts:**
- Corrects 2 samples per discontinuity (extendable to 3-4 for better quality)
- Variable `t` = phase/2π (normalized 0-1), `dt` = frequency/sampleRate
- Generate naive waveform, then subtract poly_blep(t) at discontinuities

**Core Algorithm:**
```typescript
function polyBlep(t: number, dt: number): number {
  // t: normalized phase [0, 1]
  // dt: phase increment per sample
  if (t < dt) {
    // Beginning of period
    const x = t / dt
    return x + x - x * x - 1.0
  } else if (t > 1.0 - dt) {
    // End of period
    const x = (t - 1.0) / dt
    return x * x + x + x + 1.0
  }
  return 0.0
}
```

**Implementation for Sawtooth:**
```typescript
function sawtoothPolyBlep(phase: number, dt: number): number {
  // Naive sawtooth: ramps from -1 to +1
  let saw = 2.0 * phase - 1.0
  // Apply correction at discontinuity (phase wrap)
  saw -= polyBlep(phase, dt)
  return saw
}
```

**Implementation for Square/Pulse:**
```typescript
function squarePolyBlep(phase: number, dt: number, pulseWidth: number = 0.5): number {
  let square = phase < pulseWidth ? 1.0 : -1.0
  // Correct both discontinuities
  square += polyBlep(phase, dt)  // Rising edge
  square -= polyBlep((phase + 1.0 - pulseWidth) % 1.0, dt)  // Falling edge
  return square
}
```

**Triangle Wave:**
Use BLAMP (integrated BLEP) for derivative discontinuities, or integrate an antialiased square wave.

**Quality Assessment:**
- Good balance of simplicity and quality
- Moderate aliasing reduction, slightly duller than minBLEP
- **PolyBLEP + 2x oversampling = excellent results**
- At very high frequencies: crossfade to brute-force Fourier series when fundamental approaches Nyquist
- Precision: 8-10 bits sufficient for t calculation; each bit adds ~1 octave of virtual oversampling
- Handles modulation well (unlike wavetables)

**Sources:** KVR Audio forums, Martin Finke blog, DAFx papers, Välimäki & Huovilainen papers

---

### 2.2 BLIT (Band-Limited Impulse Train)

BLIT creates streams of lowpass filtered impulses (sinc functions) that are integrated to obtain the desired bandlimited waveform.

**Key Concepts:**
- The impulse response of an ideal lowpass filter is band-limited by nature
- Unipolar BLIT → sawtooth (via integration)
- Bipolar BLIT → square wave (via integration)
- Doubly integrated bipolar BLIT → triangle

**DSF (Discrete Summation Formula):**
```typescript
function blit(phase: number, sampleRate: number, frequency: number): number {
  const P = sampleRate / frequency  // Samples per period
  const M = 2 * Math.floor(P * 0.5) + 1  // Number of harmonics
  const x = phase  // Normalized phase [0, 1]

  const denom = M * Math.sin(Math.PI * x)
  if (Math.abs(denom) < 1e-10) {
    return 1.0  // Avoid division by zero at phase = 0
  }
  return (M / P) * Math.sin(Math.PI * x * M) / denom
}
```

**Characteristics:**
- Features ringing on band edges
- Aliasing reduced but not eliminated
- Computationally expensive in real-time, often stored in tables with interpolation
- "More or less no aliasing at any frequency" - superior to BLEP in many cases

**LP-BLIT Variant:**
Uses Hammerich pulse instead of sinc for adjustable lowpass characteristic with cutoff ωc and stopband slope α.

**IIR-based BLIT:**
Better stopband rejection than FIR-based approaches.

**Implementation Note:**
Linear-phase BLEPs recommended. If oversampling for filters anyway, run BLEP oscillator at higher rate directly.

**Sources:** Stilson & Smith 1996, DAFx papers, Stanford CCRMA, music-dsp archives

---

### 2.3 minBLEP (Minimum-Phase Band-Limited Step)

minBLEP is a windowed sinc (BLIT) that has been integrated (BLEP) and converted to minimum-phase, placing the energy hump at the beginning of the window instead of the middle.

**Key Advantages:**
- No lookahead required (unlike linear-phase)
- Better quality than PolyBLEP
- Requires precomputed FFT tables

**Implementation Approach:**
1. Precompute large polyphase FIR table via FFT
2. At each discontinuity, mix the appropriate BLEP branch into output buffer
3. Scale by discontinuity height

**Algorithm:**
```typescript
// For each sample:
// 1. Increment phase
// 2. While phase > 1:
//    a. Solve exact crossing time within sample
//    b. Pick branch from polyphase BLEP table
//    c. Mix/scale into output buffer
//    d. Subtract 1 from phase
// 3. Add trivial value with latency offset
```

**Sub-sample Accuracy:**
Use oversampled pre-calculated BLEP to prevent phase noise.

**Characteristics:**
- Works gracefully above Nyquist
- Extends to piecewise polynomial waves
- Can be used for hard sync

**Criticism:**
Some argue linear-phase BLEPs are more efficient; minBLEPs have been called "a fail" due to latency concerns in certain applications.

**Sources:** Eli Brandt "Hard Sync Without Aliasing", KVR Audio forums, VCV Rack implementations

---

### 2.4 DPW (Differentiated Polynomial Waveforms)

DPW (Välimäki et al. 2010) extends differentiated parabolic wave to higher polynomial orders.

**Core Concept:**
Generate polynomial waveform, differentiate one or more times to obtain improved waveforms.

**DPW-2 (Second-Order):**
```typescript
function dpw2Sawtooth(phase: number, lastPhase: number, dt: number): number {
  // Square the naive saw
  const x0 = phase * 2.0 - 1.0  // Current naive saw
  const x1 = lastPhase * 2.0 - 1.0  // Previous naive saw

  // Parabola (squared saw)
  const p0 = x0 * x0
  const p1 = x1 * x1

  // Differentiate (difference and scale)
  return (p0 - p1) / (4.0 * dt)
}
```

**Quality Thresholds (at 44.1kHz):**
- DPW-2: Audible aliasing above 600Hz
- DPW-4: Alias-free up to ~4.6kHz
- DPW2X (DPW-2 with 2x oversampling): Recommended approach

**Aliasing Rolloff:**
6 dB/octave per differentiation order.

**Practical Issues:**
- Pitch modulation causes crackles (difficult to eliminate)
- Works best for static pitch oscillators
- Quantization noise affects each differentiation step

**Equivalence:**
DPW is equivalent to AA-FIR methods (antiderivative antialiasing).

**Sources:** Välimäki, Nam, Smith, Abel IEEE papers, music-dsp discussions

---

### 2.5 Comparison Summary

| Method | Complexity | Tables | Quality | Modulation | Best Use |
|--------|-----------|--------|---------|------------|----------|
| PolyBLEP | Simple | None | Good | Excellent | Real-time, modulated |
| BLIT | Medium | Optional | Very Good | Good | Static pitch |
| minBLEP | Complex | Required | Excellent | Excellent | Hard sync, high quality |
| DPW | Simple | None | Variable | Poor | Static oscillators |

**Recommendations:**
- For general-purpose virtual analog: PolyBLEP + 2x oversampling
- For hard sync: minBLEP
- For maximum quality: minBLEP or BLIT with tables
- Avoid: Oversampling alone (need 1024x for good results)

---

## 3. Wavetable Synthesis

### 3.1 Mipmapping Strategy

Multiple bandlimited versions at different frequency ranges prevent aliasing when playing at different pitches.

**Generation Methods:**
1. **FFT Method:** FFT → zero upper bins → IFFT → downsample
2. **Additive Synthesis:** Directly synthesize pushing harmonics to Nyquist limit (best quality)

**Table Sizes:**
- 2048 samples = "sweet spot" (covers 20Hz at 44.1kHz with ~20kHz Nyquist)
- Sine table: 512 samples = 97dB SNR (16-bit equivalent), +12dB per doubling

**Mipmap Spacing:**
- Every semitone = more than enough
- Every octave = not quite enough
- Recommended: Every octave with interpolation

**Transition Methods:**
- Switch at zero crossings (good results)
- Crossfade between mipmaps (smoother but more CPU)

### 3.2 Phase Accumulator Implementation

```typescript
interface WavetableOscillator {
  wavetable: Float32Array[]  // Array of mipmap levels
  tableSize: number
  phase: number

  getSample(frequency: number, sampleRate: number): number
}

function wavetableSample(
  osc: WavetableOscillator,
  frequency: number,
  sampleRate: number
): number {
  // Select mipmap level based on frequency
  const mipmapLevel = selectMipmapLevel(frequency, sampleRate, osc.tableSize)
  const table = osc.wavetable[mipmapLevel]

  // Phase increment
  const phaseIncrement = frequency * osc.tableSize / sampleRate

  // Fractional indexing with linear interpolation
  const indexFloat = osc.phase * osc.tableSize
  const index0 = Math.floor(indexFloat) % osc.tableSize
  const index1 = (index0 + 1) % osc.tableSize
  const frac = indexFloat - Math.floor(indexFloat)

  const sample = table[index0] * (1.0 - frac) + table[index1] * frac

  // Advance phase
  osc.phase += phaseIncrement / osc.tableSize
  if (osc.phase >= 1.0) osc.phase -= 1.0

  return sample
}
```

### 3.3 Interpolation Quality

- **Linear:** Sufficient for oversampled tables
- **Cubic/Hermite:** For non-oversampled tables
- **4-6 point spline:** For oversampled signals needing highest quality
- **Band-limited interpolation:** Build lowpass into interpolator (see Stanford CCRMA resample docs)

**Sources:** KVR Audio forums, EarLevel Engineering, music-dsp archives

---

## 4. FM/PM Synthesis

### 4.1 Fundamentals

Developed by John Chowning at Stanford (1967-1973), licensed to Yamaha 1973.

**Key Insight:**
Yamaha's implementation is actually **Phase Modulation (PM)**, mathematically equivalent to FM but with better pitch stability.

- Carrier frequency never changes, only phase
- Linear frequency mapping (PM) vs exponential (true FM)
- Patent expired 1995

### 4.2 Implementation

**Operators:** Mini-synthesizers with oscillator + envelope generator, typically sine waves.

**Algorithms:** Configurations of operators in modulator/carrier relationships.
- DX7: 32 algorithms, 6 operators
- Modern (FM-X): 8 operators with multi-spectral waveforms

```typescript
interface FMOperator {
  frequency: number
  ratio: number  // Frequency ratio to fundamental
  index: number  // Modulation index (depth)
  phase: number
  envelope: EnvelopeGenerator
}

function fmSynth(
  carrier: FMOperator,
  modulator: FMOperator,
  sampleRate: number
): number {
  // Modulator output
  const modPhaseInc = (modulator.frequency * modulator.ratio) / sampleRate
  modulator.phase += modPhaseInc
  if (modulator.phase >= 1.0) modulator.phase -= 1.0

  const modOutput = Math.sin(2 * Math.PI * modulator.phase)
    * modulator.index
    * modulator.envelope.getValue()

  // Carrier with phase modulation
  const carPhaseInc = carrier.frequency / sampleRate
  carrier.phase += carPhaseInc
  if (carrier.phase >= 1.0) carrier.phase -= 1.0

  // Apply modulation to carrier phase
  const modulatedPhase = carrier.phase + modOutput

  return Math.sin(2 * Math.PI * modulatedPhase) * carrier.envelope.getValue()
}
```

### 4.3 Key Concepts

**Modulation Index:** Controls spectral complexity (depth of modulation).

**Feedback:** Yamaha innovation - operator output routed back to input for additional sidebands.

**Carrier:Modulator Ratios:**
- Integer ratios = harmonic spectra
- Non-integer ratios = inharmonic/bell-like spectra

**Sound Design Applications:**
- Electric pianos, bells, mallets, brass
- Metallic sounds, complex attacks
- Envelope per operator: Carriers control amplitude, modulators control timbral evolution

**Sources:** Chowning papers, Yamaha documentation, Perfect Circuit, Roland articles

---

## 5. Oscillator Sync

### 5.1 Hard Sync

When the master oscillator completes a cycle, it resets the slave oscillator's phase regardless of the slave's position.

**Implementation:**
```typescript
interface SyncOscillator {
  masterPhase: number
  slavePhase: number
  masterFreq: number
  slaveFreq: number
}

function hardSyncSample(osc: SyncOscillator, sampleRate: number): number {
  const masterInc = osc.masterFreq / sampleRate
  const slaveInc = osc.slaveFreq / sampleRate

  osc.masterPhase += masterInc
  osc.slavePhase += slaveInc

  // Check for master reset
  if (osc.masterPhase >= 1.0) {
    osc.masterPhase -= 1.0
    // Reset slave to master's fractional position (important!)
    osc.slavePhase = osc.masterPhase * (slaveInc / masterInc)
  }

  // Output from slave oscillator
  return Math.sin(2 * Math.PI * osc.slavePhase)
}
```

**Bandlimited Hard Sync:**
Place BLEP at the reset point. Tricky when phase wrap and hard sync occur at same sample.

**Key Implementation Detail:**
Reset slave phase to master's phase (not zero) to avoid glitches when both oscillators have identical settings.

### 5.2 Soft Sync Variants

**Reversing Soft Sync:**
Instead of resetting to zero, the wave is inverted (direction reversed). More associated with triangle-core oscillators. Generates less aliasing due to preserved waveform continuity.

**Threshold/Weak Sync:**
Hard sync disabled when slave frequency crosses user-defined threshold or extends too far from master frequency.

**Phase Advance Sync:**
Phase of slave is advanced by fixed amount each time master crosses threshold (gentler entrainment).

**Sources:** Wikipedia, Noise Engineering, Perfect Circuit, KVR Audio forums

---

## 6. Sub-Oscillators

### 6.1 Analog Heritage

Sub-oscillators are traditionally derived from the main oscillator using flip-flop frequency dividers, not separate oscillators.

**Why Square Wave:**
The divide-by-two process itself produces a square wave output. Additional circuitry would be needed for other waveforms.

**Implementation:**
```typescript
interface SubOscillator {
  mainPhase: number
  subState: boolean  // Flip-flop state
  lastMainPhase: number
}

function subOscSample(osc: SubOscillator, mainSample: number): number {
  // Detect main oscillator zero crossing (rising edge)
  if (osc.mainPhase < osc.lastMainPhase) {
    osc.subState = !osc.subState  // Toggle on main osc reset
  }
  osc.lastMainPhase = osc.mainPhase

  return osc.subState ? 1.0 : -1.0  // Square wave one octave down
}
```

**Two-Octave Sub:**
Chain two flip-flops (divide by 4 instead of 2).

### 6.2 Digital Implementation

With minBLEP, a suboscillator is computationally cheap: just two multiplies and an add during phase reset.

**Waveform Options:**
- Digital synths can offer sine, triangle, or other sub-oscillator waveforms
- Sine wave subs add bass without coloring harmonics

**Sources:** Electric Druid, KVR Audio, Gearspace, mod wiggler

---

## 7. Supersaw / Unison

### 7.1 Roland JP-8000/8080 Supersaw

Analyzed by Adam Szabo's bachelor thesis.

**Architecture:**
- 7 sawtooth oscillators: 1 center + 6 detuned (3 pairs)
- Detune curve: Non-linear (small spread at midpoint, rapid increase at high values)
- Detune amounts: Not evenly spaced

**Key Discovery (JE-8086 emulator):**
The "secret" is 7 naive saws at 88.2kHz sample rate → highpass filter. No phase tricks or chorus required. The high sample rate prevents aliasing.

**Highpass Filter:**
Q = √2, cutoff at 2.5 × fundamental. Removes harsh noise below fundamental.

```typescript
interface SupersawOscillator {
  centerPhase: number
  detunePhases: number[]  // 6 detuned oscillators
  detuneAmounts: number[]  // Cents detune for each
  mixAmount: number  // Balance center vs detuned
}

function supersawDetune(detuneParam: number): number[] {
  // Non-linear detune curve (approximation)
  // Returns 6 detune amounts in cents
  const spread = detuneParam * detuneParam * 50  // Quadratic curve
  return [
    -spread * 0.28,
    -spread * 0.80,
    -spread * 1.00,
    spread * 0.28,
    spread * 0.80,
    spread * 1.00
  ]
}
```

### 7.2 General Unison

**Oscillator Unison:** Per-oscillator feature, minimal polyphony impact.

**Global Unison:** Full voice cards, reduces polyphony (e.g., Prophet 5 → monophonic with 5-voice unison).

**Detune Strategies:**
- Exponential spread curves
- Per-oscillator fast vibrato (20-35Hz triangle LFOs)
- Stereo spread: Pan different voices across stereo field

**Sources:** Adam Szabo thesis, JP6K plugin, KVR Audio, Synthanatomy JE-8086 article

---

## 8. LFO (Low Frequency Oscillator)

### 8.1 Fundamentals

LFOs operate below audible range (typically 0.1 Hz to 20 Hz) and modulate other parameters rather than producing sound directly.

**Common Waveforms:**
- Sine: Smooth, subtle modulation
- Triangle: Slightly more pronounced than sine
- Square: Abrupt on/off modulation
- Sawtooth: Ramp effects
- Sample & Hold: Random values at regular intervals

### 8.2 Implementation

```typescript
interface LFO {
  phase: number
  rate: number  // Hz or tempo-synced division
  waveform: 'sine' | 'triangle' | 'square' | 'saw' | 'sampleHold'
  depth: number  // Modulation amount
  isTempoSynced: boolean
}

function lfoSample(lfo: LFO, sampleRate: number): number {
  // Advance phase
  const phaseInc = lfo.rate / sampleRate
  lfo.phase += phaseInc
  if (lfo.phase >= 1.0) lfo.phase -= 1.0

  // Generate waveform
  let value: number
  switch (lfo.waveform) {
    case 'sine':
      value = Math.sin(2 * Math.PI * lfo.phase)
      break
    case 'triangle':
      value = 4 * Math.abs(lfo.phase - 0.5) - 1
      break
    case 'square':
      value = lfo.phase < 0.5 ? 1 : -1
      break
    case 'saw':
      value = 2 * lfo.phase - 1
      break
    case 'sampleHold':
      // Hold random value until phase resets
      // Requires additional state tracking
      break
  }

  return value * lfo.depth
}
```

### 8.3 Tempo Sync

```typescript
function calculateTempoSyncedRate(
  bpm: number,
  division: string  // e.g., "1/4", "1/8", "1/16"
): number {
  const beatsPerSecond = bpm / 60

  const divisionScalers: Record<string, number> = {
    '4/1': 0.25,   // 4 bars
    '2/1': 0.5,    // 2 bars
    '1/1': 1.0,    // 1 bar
    '1/2': 2.0,    // Half note
    '1/4': 4.0,    // Quarter note
    '1/8': 8.0,    // Eighth note
    '1/16': 16.0,  // Sixteenth note
    '1/32': 32.0,  // Thirty-second note
  }

  return beatsPerSecond * (divisionScalers[division] / 4)
}

// For sample-accurate sync to host position:
function syncLfoToHost(
  lfo: LFO,
  ppqPosition: number,  // Current position in quarter notes
  division: string
): void {
  const scaler = getDivisionScaler(division)
  const phase = ppqPosition * scaler
  lfo.phase = phase - Math.floor(phase)  // Fractional part only
}
```

### 8.4 Key Features

**Retrigger/Reset:**
- Monophonic: Single LFO shared by all voices
- Polyphonic: Separate LFO per voice, reset on note-on
- Free-running: No reset, continuous cycling

**Phase Offset:**
Allow starting LFO at arbitrary point in cycle.

**Fade-in/Delay:**
Gradually introduce LFO modulation after note onset.

**Audio-rate Modulation:**
LFOs above 20Hz create FM-like sideband harmonics.

**Sources:** Wikipedia, Native Instruments, LANDR, KVR Audio forums

---

## 9. Noise Generation

### 9.1 White Noise

Equal energy at all frequencies, uncorrelated samples.

```typescript
function whiteNoise(): number {
  return Math.random() * 2 - 1  // Uniform distribution [-1, 1]
}
```

**Better Quality:**
Use xorshift or Mersenne Twister for better statistical properties.

### 9.2 Pink Noise (1/f)

Equal energy per octave, -3dB/octave rolloff.

**Voss-McCartney Algorithm:**
Sum multiple white noise sources at octave-spaced update rates.

**Pinking Filter (Paul Kellet):**
```typescript
// Paul Kellet's "economy" pink noise filter
interface PinkNoiseState {
  b0: number
  b1: number
  b2: number
}

function pinkNoise(state: PinkNoiseState): number {
  const white = Math.random() * 2 - 1

  state.b0 = 0.99765 * state.b0 + white * 0.0990460
  state.b1 = 0.96300 * state.b1 + white * 0.2965164
  state.b2 = 0.57000 * state.b2 + white * 1.0526913

  return state.b0 + state.b1 + state.b2 + white * 0.1848
}
```

### 9.3 Brown Noise (1/f²)

Brownian motion, integral of white noise, -6dB/octave.

```typescript
function brownNoise(lastValue: number): number {
  const white = Math.random() * 2 - 1
  let brown = lastValue + white * 0.02
  brown = Math.max(-1, Math.min(1, brown))  // Clamp
  return brown
}
```

### 9.4 Other Colors

- **Blue noise (f):** Derivative of white, +6dB/octave
- **Violet/Purple (f²):** +12dB/octave
- **Custom:** 1/f^α where α ∈ [-2, 2]

**Sources:** firstpr.com.au DSP pink noise, music-dsp archives, Electric Druid

---

## 10. Additive Synthesis

### 10.1 Fundamentals

Sum of sinusoids at different frequencies, amplitudes, and phases.

```typescript
interface AdditivePartial {
  frequency: number  // Can be harmonic (n * fundamental) or inharmonic
  amplitude: number
  phase: number
}

function additiveSynth(
  partials: AdditivePartial[],
  fundamental: number,
  time: number
): number {
  let output = 0
  for (const partial of partials) {
    const freq = partial.frequency * fundamental
    output += partial.amplitude * Math.sin(2 * Math.PI * freq * time + partial.phase)
  }
  return output
}
```

### 10.2 Harmonic vs Inharmonic

- **Harmonic:** Integer multiples of fundamental (most pitched sounds)
- **Inharmonic:** Non-integer ratios (bells, metallic sounds)

### 10.3 Practical Challenges

- **Parameter complexity:** Large number of oscillators tedious to control
- **Transients:** Difficult - require many rapidly varying overtones
- **Organ-like quality:** Common result without careful envelope/modulation per partial

**Solutions:**
- Macro controls mapping to multiple partials
- Morphing between presets
- Analysis/resynthesis tools (SPEAR, LEMUR, LORIS, SMS)

### 10.4 Efficient Methods

- **Inverse FFT:** For evenly-spaced frequencies
- **Group additive:** Group partials into harmonic groups
- Modern systems can manage 500+ sine waves on contemporary hardware

**Sources:** Wikipedia, McGill University, Perfect Circuit, Sound on Sound

---

## 11. Vector Synthesis

### 11.1 Prophet VS (Sequential Circuits 1986)

Chris Meyer concept: 2D interpolation between 4 waveforms arranged at corners of a diamond.

**Vector Joystick:**
Traverse seamlessly between four oscillators. Mix parameter changes dynamically.

**Vector Envelope:**
Multi-breakpoint envelope controlling vector position (can loop, reverse).

### 11.2 Korg Wavestation

**Wave Sequencing:**
List of PCM waves stepped through in order (up to 255 waveforms).

**Per-step Control:**
Volume, pitch, crossfade amount, duration.

**Performance Mode:**
Up to 32 discrete wave sequences (8 patches × 4 oscillators).

### 11.3 Implementation Concept

```typescript
interface VectorOscillator {
  oscillators: [Oscillator, Oscillator, Oscillator, Oscillator]
  vectorX: number  // -1 to 1
  vectorY: number  // -1 to 1
}

function vectorMix(vec: VectorOscillator): number {
  // Convert XY to four corner weights
  const topLeft = (1 - vec.vectorX) * (1 - vec.vectorY) / 4
  const topRight = (1 + vec.vectorX) * (1 - vec.vectorY) / 4
  const bottomLeft = (1 - vec.vectorX) * (1 + vec.vectorY) / 4
  const bottomRight = (1 + vec.vectorX) * (1 + vec.vectorY) / 4

  return vec.oscillators[0].getSample() * topLeft
       + vec.oscillators[1].getSample() * topRight
       + vec.oscillators[2].getSample() * bottomLeft
       + vec.oscillators[3].getSample() * bottomRight
}
```

**Sources:** Perfect Circuit, Learning Modular, Vintage Synth Explorer

---

## 12. Phase Distortion Synthesis

### 12.1 Casio CZ Series (1984)

Developed by Mark Fukuda.

**Core Concept:**
Scan sine wave lookup table at varying speed while keeping frequency constant. This distorts the phase of the phasor reading through the sine table.

**8 Waveforms:**
Saw, square, pulse, double sine, half-sine, resonant saw, resonant triangle, resonant trapezoid.

**DCW (Digitally Controlled Wave):**
Controls magnitude of phase distortion (0 = sine, max = selected shape). Acts like VCF cutoff.

### 12.2 Implementation

```typescript
function phaseDistortion(
  phase: number,        // Linear phase [0, 1]
  distortionAmount: number,  // 0 = sine, 1 = full distortion
  waveformType: string
): number {
  // Transform linear phase to distorted phase
  let distortedPhase: number

  switch (waveformType) {
    case 'saw':
      // Faster at start, slower at end
      distortedPhase = acceleratedPhase(phase, distortionAmount)
      break
    case 'resonant':
      // Windowed sync technique
      distortedPhase = resonantPhase(phase, distortionAmount)
      break
    // ... other waveforms
  }

  return Math.sin(2 * Math.PI * distortedPhase)
}

function acceleratedPhase(phase: number, amount: number): number {
  // Simple example: accelerate through first half, decelerate through second
  if (phase < 0.5) {
    const rate = 1 + amount
    return phase * rate * 2
  } else {
    return 1 - (1 - phase) * 2
  }
}
```

### 12.3 vs FM/PM

- PD: Modulators at same frequency as carrier, limited frequency range
- PD: More linear spectra (easier to produce traditional subtractive sounds)
- FM: Bessel function-derived spectra
- PD: Modulator waveshape can be modified

**Sources:** Wikipedia, Electric Druid, Pro Audio Files, MusicRadar, DAFx papers

---

## 13. Waveform Morphing

### 13.1 Methods

**Simple Crossfade:**
Works if waveforms are phase-aligned. Requires equal-power crossfade for non-phase-locked sources.

```typescript
function crossfade(a: number, b: number, mix: number): number {
  // Linear crossfade
  return a * (1 - mix) + b * mix
}

function equalPowerCrossfade(a: number, b: number, mix: number): number {
  // Equal power (constant loudness)
  return a * Math.cos(mix * Math.PI / 2) + b * Math.sin(mix * Math.PI / 2)
}
```

**Additive/Spectral Morphing:**
Interpolate gains of individual partials from one wave to another.

```typescript
function spectralMorph(
  partialsA: number[],
  partialsB: number[],
  mix: number
): number[] {
  return partialsA.map((a, i) =>
    a * (1 - mix) + partialsB[i] * mix
  )
}
```

**Control Point Morphing:**
Construct waves from key points and curves, interpolate between corresponding key points.

### 13.2 Wavetable Interpolation Types

- **1D:** String of waves (Serum, Vital, Iridium)
- **2D:** XY grid (Synthesis Technology modules, 4MS SWN)
- **3D:** XYZ cube (Plaits)

**Sources:** cycling74 forums, mod wiggler, KVR Audio, Stanford CCRMA

---

## 14. Advanced Techniques

### 14.1 Feedback FM

Operator output routed back to input (self-modulation or cross-modulation).

**Characteristics:**
- Creates additional sidebands without extra operators
- Chaotic behavior: Too much feedback → instability, noise
- Related to iterated nonlinear map dynamics (logistic map)

### 14.2 Waveshaping

Non-linear transfer function applied to input signal.

```typescript
// Soft clipping (tanh)
function tanhWaveshaper(input: number, drive: number): number {
  return Math.tanh(input * drive)
}

// Chebyshev polynomial waveshaping
function chebyshev(input: number, order: number): number {
  // Generates nth harmonic from sine input
  return Math.cos(order * Math.acos(input))
}
```

**Note:** Avoid hard clipping on audio-rate signals as it reintroduces aliasing.

### 14.3 Through-Zero FM (TZFM)

Linear FM that crosses through zero frequency, producing unique timbres impossible with standard FM.

### 14.4 Chaotic Synthesis

Complex oscillator with two oscillators cross-modulating frequency/amplitude.

- Mild settings: Unique harmonically rich timbres
- Increased modulation: Noise bursts, pulsing rhythms
- Strange attractors: Underlying order within chaos

**Sources:** KVR Audio, mod wiggler, academic papers on nonlinear dynamics

---

## 15. Recommendations for Krate Audio

### Anti-Aliasing Strategy

1. **Primary:** PolyBLEP with optional 2x oversampling for quality-critical applications
2. **Hard Sync:** minBLEP for proper bandlimited sync
3. **High frequencies:** Crossfade to limited-harmonic fallback near Nyquist

### Oscillator Architecture

```typescript
interface KrateOscillator {
  // Core
  phase: number
  frequency: number
  waveform: WaveformType

  // Anti-aliasing
  antiAliasMethod: 'polyblep' | 'minblep' | 'none'
  oversampleFactor: 1 | 2 | 4

  // Modulation
  phaseModInput: number
  frequencyModInput: number

  // Sync
  syncEnabled: boolean
  syncInput: number

  // Sub-oscillator
  subEnabled: boolean
  subOctave: 1 | 2
  subWaveform: 'square' | 'sine' | 'triangle'
  subMix: number
}
```

### Feature Priority

1. **Phase 1:** Basic oscillators with PolyBLEP (saw, square, pulse, triangle)
2. **Phase 2:** Wavetable oscillator with mipmap support
3. **Phase 3:** FM/PM synthesis module
4. **Phase 4:** Hard sync with minBLEP
5. **Phase 5:** Advanced features (vector, morphing, chaos)

---

## References

### Papers
- Välimäki, V., & Huovilainen, A. "Antialiasing Oscillators in Subtractive Synthesis" (IEEE)
- Stilson, T., & Smith, J. "Alias-Free Digital Synthesis of Classic Analog Waveforms" (ICMC 1996)
- Brandt, E. "Hard Sync Without Aliasing" (ICMC 2001)
- Szabo, A. "Analysis of the Roland JP-8000 Supersaw" (Bachelor's Thesis)
- Chowning, J. "The Synthesis of Complex Audio Spectra by Means of Frequency Modulation"

### Online Resources
- KVR Audio DSP Forum: https://www.kvraudio.com/forum/
- music-dsp mailing list archives
- Stanford CCRMA: https://ccrma.stanford.edu/
- Electric Druid: https://electricdruid.net/
- EarLevel Engineering: https://www.earlevel.com/

### Code References
- VCV Rack (open source): https://github.com/VCVRack/Rack
- Surge Synthesizer: https://github.com/surge-synthesizer/surge
- Dexed (DX7 emulator): https://github.com/asb2m10/dexed
