// ==============================================================================
// API Contract: ArpeggiatorCore (Layer 2 Processor)
// ==============================================================================
// This file documents the public API contract for the ArpeggiatorCore class.
// It is NOT compiled -- it serves as the authoritative reference for the
// implementation and test development.
//
// Actual implementation: dsp/include/krate/dsp/processors/arpeggiator_core.h
// Actual tests: dsp/tests/unit/processors/arpeggiator_core_test.cpp
// ==============================================================================

#pragma once

#include <krate/dsp/core/block_context.h>
#include <krate/dsp/core/note_value.h>
#include <krate/dsp/primitives/held_note_buffer.h>

#include <array>
#include <cstddef>
#include <cstdint>
#include <span>

namespace Krate::DSP {

// =============================================================================
// Enumerations (FR-027, FR-028)
// =============================================================================

/// @brief How the arp handles key release.
enum class LatchMode : uint8_t {
    Off = 0,  ///< Stop when all keys released
    Hold,     ///< Continue playing latched pattern; new keys replace
    Add       ///< Accumulate notes into pattern
};

/// @brief When the arp pattern resets.
/// Named ArpRetriggerMode to avoid ODR conflict with RetriggerMode in envelope_utils.h.
enum class ArpRetriggerMode : uint8_t {
    Off = 0,  ///< Never auto-reset
    Note,     ///< Reset on each incoming noteOn
    Beat      ///< Reset at bar boundaries
};

// =============================================================================
// ArpEvent (FR-001, FR-002)
// =============================================================================

/// @brief A timestamped MIDI event generated by the arpeggiator.
struct ArpEvent {
    enum class Type : uint8_t { NoteOn, NoteOff };

    Type type{Type::NoteOn};
    uint8_t note{0};          ///< MIDI note number (0-127)
    uint8_t velocity{0};      ///< MIDI velocity (0-127)
    int32_t sampleOffset{0};  ///< Sample position within block [0, blockSize-1]
};

// =============================================================================
// ArpeggiatorCore (FR-003 through FR-032)
// =============================================================================

/// @brief Layer 2 DSP processor: arpeggiator timing and event generation.
///
/// Composes HeldNoteBuffer + NoteSelector (Layer 1) with integer timing
/// to produce sample-accurate ArpEvent sequences. Header-only, zero heap
/// allocation in all methods.
///
/// @par Real-Time Safety
/// All methods are noexcept. Zero heap allocation. No locks, exceptions, or I/O.
///
/// @par Usage
/// @code
/// ArpeggiatorCore arp;
/// arp.prepare(44100.0, 512);
/// arp.setEnabled(true);
/// arp.setMode(ArpMode::Up);
/// arp.setNoteValue(NoteValue::Eighth, NoteModifier::None);
/// arp.noteOn(60, 100);
/// arp.noteOn(64, 100);
///
/// std::array<ArpEvent, 64> events;
/// BlockContext ctx;
/// ctx.isPlaying = true;
/// size_t count = arp.processBlock(ctx, events);
/// @endcode
class ArpeggiatorCore {
public:
    // =========================================================================
    // Constants
    // =========================================================================

    static constexpr size_t kMaxEvents = 64;
    static constexpr size_t kMaxPendingNoteOffs = 32;
    static constexpr double kMinSampleRate = 1000.0;
    static constexpr float kMinFreeRate = 0.5f;
    static constexpr float kMaxFreeRate = 50.0f;
    static constexpr float kMinGateLength = 1.0f;
    static constexpr float kMaxGateLength = 200.0f;
    static constexpr float kMinSwing = 0.0f;
    static constexpr float kMaxSwing = 75.0f;

    // =========================================================================
    // Lifecycle (FR-003, FR-004)
    // =========================================================================

    /// @brief Initialize for processing.
    /// @param sampleRate Sample rate in Hz (clamped to >= 1000)
    /// @param maxBlockSize Maximum block size (for validation)
    void prepare(double sampleRate, size_t maxBlockSize) noexcept;

    /// @brief Reset all state to initial values. Configuration preserved.
    void reset() noexcept;

    // =========================================================================
    // MIDI Input (FR-005, FR-006, FR-007)
    // =========================================================================

    /// @brief Handle incoming MIDI note-on.
    /// Applies latch logic (replace vs accumulate) and retrigger logic.
    void noteOn(uint8_t note, uint8_t velocity) noexcept;

    /// @brief Handle incoming MIDI note-off.
    /// Behavior depends on latch mode (remove, ignore, or track).
    void noteOff(uint8_t note) noexcept;

    // =========================================================================
    // Configuration (FR-008 through FR-018)
    // =========================================================================

    void setEnabled(bool enabled) noexcept;
    void setMode(ArpMode mode) noexcept;
    void setOctaveRange(int octaves) noexcept;
    void setOctaveMode(OctaveMode mode) noexcept;
    void setTempoSync(bool sync) noexcept;
    void setNoteValue(NoteValue val, NoteModifier mod) noexcept;
    void setFreeRate(float hz) noexcept;
    void setGateLength(float percent) noexcept;
    void setSwing(float percent) noexcept;
    void setLatchMode(LatchMode mode) noexcept;
    void setRetrigger(ArpRetriggerMode mode) noexcept;

    // =========================================================================
    // Processing (FR-019 through FR-024)
    // =========================================================================

    /// @brief Process one audio block, generating arp events.
    /// @param ctx Block context (tempo, sample rate, transport state)
    /// @param outputEvents Caller-owned span to receive events (capacity >= 64)
    /// @return Number of events written to outputEvents
    ///
    /// @pre outputEvents.size() >= kMaxEvents
    /// @post All events have sampleOffset in [0, ctx.blockSize-1]
    ///
    /// Behavior:
    /// - Returns 0 if ctx.blockSize == 0 (FR-032, no state change)
    /// - Returns 0 if disabled (FR-008, emits NoteOff on disable transition)
    /// - Returns 0 if not playing (FR-031, emits NoteOff on stop transition)
    /// - Returns 0 if held buffer empty and latch off (FR-024)
    /// - Otherwise: advances timing, emits NoteOn/NoteOff at step boundaries
    size_t processBlock(const BlockContext& ctx,
                        std::span<ArpEvent> outputEvents) noexcept;
};

} // namespace Krate::DSP
